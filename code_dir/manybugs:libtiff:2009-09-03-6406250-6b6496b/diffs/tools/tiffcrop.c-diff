8a9
>  * Additions (c) Richard Nolde 2006-2009 
22,27c23,28
<  * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
<  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
<  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
<  * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
<  * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
<  * OF THIS SOFTWARE.
---
>  * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS OR ANY OTHER COPYRIGHT  
>  * HOLDERS BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL 
>  * DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
>  * DATA OR PROFITS, WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND 
>  * ON ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE
>  * OR PERFORMANCE OF THIS SOFTWARE.
29,30c30,31
<  * The portions of the current code that are derived from tiffcp are primarly 
<  * in the areas of lowlevel reading and writing of scanlines and tiles though
---
>  * Some portions of the current code are derived from tiffcp, primarly in 
>  * the areas of lowlevel reading and writing of TAGSscanlines and tiles though
34,40d34
<  * Additions (c) Richard Nolde 2006-2009 Last Updated 1/6/2009 
<  * IN NO EVENT SHALL RICHARD NOLDE BE LIABLE FOR ANY SPECIAL, INCIDENTAL, 
<  * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER 
<  * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF 
<  * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  LIABILITY, ARISING OUT 
<  * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
<  *
48c42
<  * Options: 
---
>  * New Options: 
50c44
<  * -v             Report the version and last build date for tiffcrop
---
>  * -v             Report the version and last build date for tiffcrop and libtiff.
68c62,63
<  *                units
---
>  *                units when sectioning image into columns x rows 
>  *                using the -S cols:rows option.
70c65,66
<  *                units
---
>  *                units when sectioning image into columns x rows
>  *                using the -S cols:rows option.
111a108,109
>  * -c for compression extended to allow explicit specification of RAW or AUTO mode
>  *                with JPEG compression.
113a112,114
> static   char tiffcrop_version_id[] = "2.1";
> static   char tiffcrop_rev_date[] = "09-18-2009";
> 
205c206
< #define MAX_IMAGES 1024  /* number of images in descrete list, not in the file */
---
> #define MAX_IMAGES 2048  /* number of images in descrete list, not in the file */
271c272,275
< /* Cropping parameters from command line and image data */
---
> /* Cropping parameters from command line and image data 
>  * Note: This should be renamed to proc_opts and expanded to include all current globals
>  * if possible, but each function that accesses global variables will have to be redone.
>  */
425,426c429,430
< static uint32 tilewidth;
< static uint32 tilelength;
---
> static uint32 tilewidth = 0;
> static uint32 tilelength = 0;
428,433c432,437
< static uint16 config;
< static uint16 compression;
< static uint16 predictor;
< static uint16 fillorder;
< static uint32 rowsperstrip;
< static uint32 g3opts;
---
> static uint16 config = 0;
> static uint16 compression = 0;
> static uint16 predictor = 0;
> static uint16 fillorder = 0;
> static uint32 rowsperstrip = 0;
> static uint32 g3opts = 0;
436,437c440,441
< static int    quality = 75;		/* JPEG quality */
< static int    jpegcolormode = JPEGCOLORMODE_RGB;
---
> static int    quality = 100;		/* JPEG quality */
> static int    jpegcolormode = -1;       /* was JPEGCOLORMODE_RGB; */
443,457c447,457
< /* Functions adapted from tiffcp with additions or modifications */
< static int readContigStripsIntoBuffer   (TIFF*, uint8*, uint32, uint32, tsample_t);
< static int readSeparateStripsIntoBuffer (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);
< static int readContigTilesIntoBuffer    (TIFF*, uint8*, uint32, uint32, tsample_t);
< static int readSeparateTilesIntoBuffer  (TIFF*, uint8*, uint32, uint32, tsample_t);
< static int writeBufferToContigStrips    (TIFF*, uint8*, uint32, uint32, tsample_t);
< static int writeBufferToContigTiles     (TIFF*, uint8*, uint32, uint32, tsample_t);
< static int writeBufferToSeparateStrips  (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);
< static int writeBufferToSeparateTiles   (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);
< static int extractContigSamplesToBuffer (uint8 *, uint8 *, uint32, uint32, int, int, 
<                                          tsample_t, uint16, uint16, struct dump_opts *);
< static void cpStripToTile (uint8*, uint8*, uint32, uint32, int, int);
< static void cpSeparateBufToContigBuf(uint8 *, uint8 *, uint32, uint32 , 
< 				     int, int, tsample_t, int);
< 
---
> /* Functions adapted from tiffcp with additions or significant modifications */
> static int  readContigStripsIntoBuffer   (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);
> static int  readSeparateStripsIntoBuffer (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);
> static int  readContigTilesIntoBuffer    (TIFF*, uint8*, uint32, uint32, uint32, uint32, tsample_t, uint16);
> static int  readSeparateTilesIntoBuffer  (TIFF*, uint8*, uint32, uint32, uint32, uint32, tsample_t, uint16);
> static int  writeBufferToContigStrips    (TIFF*, uint8*, uint32);
> static int  writeBufferToContigTiles     (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);
> static int  writeBufferToSeparateStrips  (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);
> static int  writeBufferToSeparateTiles   (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);
> static int  extractContigSamplesToBuffer (uint8 *, uint8 *, uint32, uint32, tsample_t, 
>                                          uint16, uint16, struct dump_opts *);
461c461
< /* New functions by Richard Nolde  not found in tiffcp */
---
> /* All other functions by Richard Nolde,  not found in tiffcp */
568a569,572
> static int extractContigSamplesToTileBuffer(uint8 *, uint8 *, uint32, uint32,
>   	                                    uint32, uint32, tsample_t, uint16,
> 					    uint16, uint16, struct dump_opts *);
> 
579,580c583,600
<                                        uint32, uint32, tsample_t, uint16, 
<                                        FILE *, int, int);
---
> 					uint32, uint32, tsample_t, uint16,
>                                         FILE *, int, int);
> 
> static int combineSeparateTileSamples8bits (uint8 *[], uint8 *, uint32, uint32,
>                                             uint32, uint32, uint16, uint16, 
>                                             FILE *, int, int);
> static int combineSeparateTileSamples16bits (uint8 *[], uint8 *, uint32, uint32,
>                                              uint32, uint32, uint16, uint16,
>                                              FILE *, int, int);
> static int combineSeparateTileSamples24bits (uint8 *[], uint8 *, uint32, uint32,
>                                              uint32, uint32, uint16, uint16,
>                                              FILE *, int, int);
> static int combineSeparateTileSamples32bits (uint8 *[], uint8 *, uint32, uint32,
>                                              uint32, uint32, uint16, uint16,
>                                              FILE *, int, int);
> static int combineSeparateTileSamplesBytes (unsigned char *[], unsigned char *,
> 			  		    uint32, uint32, uint32, uint32, 
>                                             tsample_t, uint16, FILE *, int, int);
593d612
< 
596,597d614
< static   char tiffcrop_version_id[] = "2.0";
< static   char tiffcrop_rev_date[] = "01-06-2009";
634,635c651,653
< " #		Set compression quality level (0-100, default 75)",
< " r		Output color image as RGB rather than YCbCr",
---
> " #		Set compression quality level (0-100, default 100)",
> " r		Output color image as raw RGB rather than YCbCr",
> " a		Output color image as RGB or YCbCr with auto detection",
678a697
> "             when sectioning image into columns x rows using the -S cols:rows option",
679a699
> "             when sectioning image into columns x rows using the -S cols:rows option",
703,704c723,724
< "             increase the level of detail. The program must be compiled with",
< "             -DDEBUG -DDEBUG2 to enable full debug reporting",
---
> "             increase the level of detail. Note: Tiffcrop may be compiled with",
> "             -DDEVELMODE to enable additional very low level debug reporting.",
706c726
< "   format:txt|raw  Format any logged data as ASCII text or raw binary ",
---
> "   Format:txt|raw  Format any logged data as ASCII text or raw binary ",
727a748,752
> /* This function could be modified to pass starting sample offset 
>  * and number of samples as args to select fewer than spp
>  * from input image. These would then be passed to individual 
>  * extractContigSampleXX routines.
>  */
731,775c756,821
<                                       tsample_t spp)
< {
< 	int status = 1;
< 	tdata_t tilebuf = _TIFFmalloc(TIFFTileSize(in));
< 	uint32 imagew = TIFFScanlineSize(in);
< 	uint32 tilew  = TIFFTileRowSize(in);
< 	int iskew = imagew - tilew;
< 	uint8* bufp = (uint8*) buf;
< 	uint32 tw, tl;
< 	uint32 row;
< 
< 	(void) spp;
< 	if (tilebuf == 0)
< 		return 0;
< 	(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);
< 	(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);
<         
< 	for (row = 0; row < imagelength; row += tl) {
< 		uint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;
< 		uint32 colb = 0;
< 		uint32 col;
< 
< 		for (col = 0; col < imagewidth; col += tw) {
< 			if (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0
< 			    && !ignore) {
< 				TIFFError(TIFFFileName(in),
< 					  "Error, can't read tile at %lu %lu",
< 					  (unsigned long) col,
< 					  (unsigned long) row);
< 				status = 0;
< 				goto done;
< 			}
< 			if (colb + tilew > imagew) {
< 				uint32 width = imagew - colb;
< 				uint32 oskew = tilew - width;
< 				cpStripToTile(bufp + colb,
<                                               tilebuf, nrow, width,
<                                               oskew + iskew, oskew );
< 			} else
< 				cpStripToTile(bufp + colb,
<                                               tilebuf, nrow, tilew,
<                                               iskew, 0);
< 			colb += tilew;
< 		}
< 		bufp += imagew * nrow;
---
>                                       uint32 tw, uint32 tl,
>                                       tsample_t spp, uint16 bps)
>   {
>   int status = 1;
>   tsample_t sample = 0;
>   tsample_t count = spp; 
>   uint32 row, col, trow;
>   uint32 nrow, ncol;
>   uint32 dst_rowsize, shift_width;
>   uint32 bytes_per_sample, bytes_per_pixel;
>   uint32 trailing_bits, prev_trailing_bits;
>   uint32 tile_rowsize  = TIFFTileRowSize(in);
>   uint32 src_offset, dst_offset;
>   uint32 row_offset, col_offset;
>   uint8 *bufp = (uint8*) buf;
>   unsigned char *src = NULL;
>   unsigned char *dst = NULL;
>   tsize_t tbytes = 0, tile_buffsize = 0;
>   tsize_t tilesize = TIFFTileSize(in);
>   unsigned char *tilebuf = NULL;
> 
>   bytes_per_sample = (bps + 7) / 8; 
>   bytes_per_pixel  = ((bps * spp) + 7) / 8;
> 
>   if ((bps % 8) == 0)
>     shift_width = 0;
>   else
>     {
>     if (bytes_per_pixel < (bytes_per_sample + 1))
>       shift_width = bytes_per_pixel;
>     else
>       shift_width = bytes_per_sample + 1;
>     }
> 
>   tile_buffsize = tilesize;
> 
>   if (tilesize < (tsize_t)(tl * tile_rowsize))
>     {
> #ifdef DEBUG2
>     TIFFError("readContigTilesIntoBuffer",
> 	      "Tilesize %lu is too small, using alternate calculation %u",
>               tilesize, tl * tile_rowsize);
> #endif
>     tile_buffsize = tl * tile_rowsize;
>     } 
> 
>   tilebuf = _TIFFmalloc(tile_buffsize);
>   if (tilebuf == 0)
>     return 0;
> 
>   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;  
>   for (row = 0; row < imagelength; row += tl)
>     {
>     nrow = (row + tl > imagelength) ? imagelength - row : tl;
>     for (col = 0; col < imagewidth; col += tw)
>       {
>       tbytes = TIFFReadTile(in, tilebuf, col, row, 0, 0);
>       if (tbytes < tilesize  && !ignore)
>         {
> 	TIFFError(TIFFFileName(in),
> 		  "Error, can't read tile at row %lu col %lu, Read %lu bytes of %lu",
> 		  (unsigned long) col, (unsigned long) row, (unsigned long)tbytes,
>                   (unsigned long)tilesize);
> 		  status = 0;
>                   _TIFFfree(tilebuf);
> 		  return status;
777,780c823,852
< done:
< 	_TIFFfree(tilebuf);
< 	return status;
< }
---
>       
>       row_offset = row * dst_rowsize;
>       col_offset = ((col * bps * spp) + 7)/ 8;
>       bufp = buf + row_offset + col_offset;
> 
>       if (col + tw > imagewidth)
> 	ncol = imagewidth - col;
>       else
>         ncol = tw;
> 
>       /* Each tile scanline will start on a byte boundary but it
>        * has to be merged into the scanline for the entire
>        * image buffer and the previous segment may not have
>        * ended on a byte boundary
>        */
>       /* Optimization for common bit depths, all samples */
>       if (((bps % 8) == 0) && (count == spp))
>         {
> 	for (trow = 0; trow < nrow; trow++)
>           {
> 	  src_offset = trow * tile_rowsize;
> 	  _TIFFmemcpy (bufp, tilebuf + src_offset, (ncol * spp * bps) / 8);
>           bufp += (imagewidth * bps * spp) / 8;
> 	  }
>         }
>       else
>         {
> 	/* Bit depths not a multiple of 8 and/or extract fewer than spp samples */
>         prev_trailing_bits = trailing_bits = 0;
>         trailing_bits = (ncol * bps * spp) % 8;
782,846c854,932
< static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *buf, 
<             uint32 imagelength, uint32 imagewidth, uint16 spp)
< {
< 	int status = 1;
< 	uint32 imagew = TIFFRasterScanlineSize(in);
< 	uint32 tilew = TIFFTileRowSize(in);
< 	int iskew  = imagew - tilew*spp;
< 	tdata_t tilebuf = _TIFFmalloc(TIFFTileSize(in));
< 	uint8* bufp = (uint8*) buf;
< 	uint32 tw, tl;
< 	uint32 row;
<         uint16 bps, bytes_per_sample;
< 
< 	if (tilebuf == 0)
< 		return 0;
< 	(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);
< 	(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);
< 	(void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);
<         assert( bps % 8 == 0 );
<         bytes_per_sample = bps/8;
< 
< 	for (row = 0; row < imagelength; row += tl) {
< 		uint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;
< 		uint32 colb = 0;
< 		uint32 col;
< 
< 		for (col = 0; col < imagewidth; col += tw) {
< 			tsample_t s;
< 
< 			for (s = 0; s < spp; s++) {
< 				if (TIFFReadTile(in, tilebuf, col, row, 0, s) < 0
< 				    && !ignore) {
< 					TIFFError(TIFFFileName(in),
< 					  "Error, can't read tile at %lu %lu, "
< 					  "sample %lu",
< 					  (unsigned long) col,
< 					  (unsigned long) row,
< 					  (unsigned long) s);
< 					status = 0;
< 					goto done;
< 				}
< 				/*
< 				 * Tile is clipped horizontally.  Calculate
< 				 * visible portion and skewing factors.
< 				 */
< 				if (colb + tilew*spp > imagew) {
< 					uint32 width = imagew - colb;
< 					int oskew = tilew*spp - width;
< 					cpSeparateBufToContigBuf(
<                                             bufp+colb+s*bytes_per_sample,
< 					    tilebuf, nrow,
<                                             width/(spp*bytes_per_sample),
< 					    oskew + iskew,
<                                             oskew/spp, spp,
<                                             bytes_per_sample);
< 				} else
< 					cpSeparateBufToContigBuf(
<                                             bufp+colb+s*bytes_per_sample,
< 					    tilebuf, nrow, tw,
< 					    iskew, 0, spp,
<                                             bytes_per_sample);
< 			}
< 			colb += tilew*spp;
< 		}
< 		bufp += imagew * nrow;
---
> 	/*	for (trow = 0; tl < nrow; trow++) */
> 	for (trow = 0; trow < nrow; trow++)
>           {
> 	  src_offset = trow * tile_rowsize;
>           src = tilebuf + src_offset;
> 	  dst_offset = (row + trow) * dst_rowsize;
>           dst = buf + dst_offset + col_offset;
>           switch (shift_width)
>             {
>             case 0: if (extractContigSamplesBytes (src, dst, ncol, sample,
>                                                    spp, bps, count, 0, ncol))
>                       {
> 		      TIFFError("readContigTilesIntoBuffer",
>                                 "Unable to extract row %d from tile %lu", 
> 				row, (unsigned long)TIFFCurrentTile(in));
> 		      return (1);
> 		      }
> 		    break;
>             case 1: if (bps == 1)
>                       { 
>                       if (extractContigSamplesShifted8bits (src, dst, ncol,
>                                                             sample, spp,
>                                                             bps, count,
>                                                             0, ncol,
>                                                             prev_trailing_bits))
>                         {
> 		        TIFFError("readContigTilesIntoBuffer",
>                                   "Unable to extract row %d from tile %lu", 
> 				  row, (unsigned long)TIFFCurrentTile(in));
> 		        return (1);
> 		        }
> 		      break;
> 		      }
>                     else
>                       if (extractContigSamplesShifted16bits (src, dst, ncol,
>                                                              sample, spp,
>                                                              bps, count,
>                                                              0, ncol,
>                                                              prev_trailing_bits))
>                         {
> 		        TIFFError("readContigTilesIntoBuffer",
>                                   "Unable to extract row %d from tile %lu", 
> 			  	  row, (unsigned long)TIFFCurrentTile(in));
> 		        return (1);
> 		        }
> 	            break;
>             case 2: if (extractContigSamplesShifted24bits (src, dst, ncol,
>                                                            sample, spp,
>                                                            bps, count,
>                                                            0, ncol,
>                                                            prev_trailing_bits))
>                       {
> 		      TIFFError("readContigTilesIntoBuffer",
>                                 "Unable to extract row %d from tile %lu", 
> 		  	        row, (unsigned long)TIFFCurrentTile(in));
> 		      return (1);
> 		      }
> 		    break;
>             case 3:
>             case 4:
>             case 5: if (extractContigSamplesShifted32bits (src, dst, ncol,
>                                                            sample, spp,
>                                                            bps, count,
>                                                            0, ncol,
>                                                            prev_trailing_bits))
>                       {
> 		      TIFFError("readContigTilesIntoBuffer",
>                                 "Unable to extract row %d from tile %lu", 
> 			        row, (unsigned long)TIFFCurrentTile(in));
> 		      return (1);
> 		      }
> 		    break;
>             default: TIFFError("readContigTilesIntoBuffer", "Unsupported bit depth %d", bps);
> 		     return (1);
> 	    }
>           }
>         prev_trailing_bits += trailing_bits;
>         if (prev_trailing_bits > 7)
> 	  prev_trailing_bits-= 8;
848,851c934,935
< done:
< 	_TIFFfree(tilebuf);
< 	return status;
< }
---
>       }
>     }
853,857c937,939
< static int writeBufferToContigStrips(TIFF* out, uint8* buf, uint32 imagelength, 
<                                      uint32 imagewidth, tsample_t spp)
< {
< 	uint32 row, rowsperstrip;
< 	tstrip_t strip = 0;
---
>   _TIFFfree(tilebuf);
>   return status;
>   }
859,870c941,1000
< 	(void) imagewidth; (void) spp;
< 	(void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);
< 	for (row = 0; row < imagelength; row += rowsperstrip) {
< 		uint32 nrows = (row+rowsperstrip > imagelength) ?
< 		    imagelength-row : rowsperstrip;
< 		tsize_t stripsize = TIFFVStripSize(out, nrows);
< 		if (TIFFWriteEncodedStrip(out, strip++, buf, stripsize) < 0) {
< 			TIFFError(TIFFFileName(out),
< 				  "Error, can't write strip %u", strip - 1);
< 			return 0;
< 		}
< 		buf += stripsize;
---
> static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf, 
> 					 uint32 imagelength, uint32 imagewidth, 
>                                          uint32 tw, uint32 tl,
>                                          uint16 spp, uint16 bps)
>   {
>   int     i, status = 1, sample;
>   int     shift_width, bytes_per_pixel;
>   uint16  bytes_per_sample;
>   uint32  row, col;     /* Current row and col of image */
>   uint32  nrow, ncol;   /* Number of rows and cols in current tile */
>   uint32  row_offset, col_offset; /* Output buffer offsets */
>   tsize_t tbytes = 0, tilesize = TIFFTileSize(in);
>   tsample_t s;
>   uint8*  bufp = (uint8*)obuf;
>   unsigned char *srcbuffs[MAX_SAMPLES];
>   unsigned char *tbuff = NULL;
> 
>   bytes_per_sample = (bps + 7) / 8;
> 
>   for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)
>     {
>     srcbuffs[sample] = NULL;
>     tbuff = (unsigned char *)_TIFFmalloc(tilesize + 8);
>     if (!tbuff)
>       {
>       TIFFError ("readSeparateStripsIntoBuffer", 
>                  "Unable to allocate tile read buffer for sample %d", sample);
>       for (i = 0; i < sample; i++)
>         _TIFFfree (srcbuffs[i]);
>       return 0;
>       }
>     srcbuffs[sample] = tbuff;
>     } 
>   /* Each tile contains only the data for a single plane
>    * arranged in scanlines of tw * bytes_per_sample bytes.
>    */
>   for (row = 0; row < imagelength; row += tl)
>     {
>     nrow = (row + tl > imagelength) ? imagelength - row : tl;
>     for (col = 0; col < imagewidth; col += tw)
>       {
>       for (s = 0; s < spp; s++)
>         {  /* Read each plane of a tile set into srcbuffs[s] */
> 	tbytes = TIFFReadTile(in, srcbuffs[s], col, row, 0, s);
>         if (tbytes < 0  && !ignore)
>           {
> 	  TIFFError(TIFFFileName(in),
>                  "Error, can't read tile for row %lu col %lu, "
> 		 "sample %lu",
> 		 (unsigned long) col, (unsigned long) row,
> 		 (unsigned long) s);
> 		 status = 0;
>           for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)
>             {
>             tbuff = srcbuffs[sample];
>             if (tbuff != NULL)
>               _TIFFfree(tbuff);
>             }
>           return status;
> 	  }
872,873c1002,1109
< 	return 1;
< }
---
>      /* Tiles on the right edge may be padded out to tw 
>       * which must be a multiple of 16.
>       * Ncol represents the visible (non padding) portion.  
>       */
>       if (col + tw > imagewidth)
>         ncol = imagewidth - col;
>       else
>         ncol = tw;
> 
>       row_offset = row * (((imagewidth * spp * bps) + 7) / 8);
>       col_offset = ((col * spp * bps) + 7) / 8;
>       bufp = obuf + row_offset + col_offset;
> 
>       if ((bps % 8) == 0)
>         {
>         if (combineSeparateTileSamplesBytes(srcbuffs, bufp, ncol, nrow, imagewidth,
> 					    tw, spp, bps, NULL, 0, 0))
> 	  {
>           status = 0;
>           break;
>       	  }
> 	}
>       else
>         {
>         bytes_per_pixel  = ((bps * spp) + 7) / 8;
>         if (bytes_per_pixel < (bytes_per_sample + 1))
>           shift_width = bytes_per_pixel;
>         else
>           shift_width = bytes_per_sample + 1;
> 
>         switch (shift_width)
>           {
>           case 1: if (combineSeparateTileSamples8bits (srcbuffs, bufp, ncol, nrow,
>                                                        imagewidth, tw, spp, bps, 
> 						       NULL, 0, 0))
> 	            {
>                     status = 0;
>                     break;
>       	            }
> 	          break;
>           case 2: if (combineSeparateTileSamples16bits (srcbuffs, bufp, ncol, nrow,
>                                                        imagewidth, tw, spp, bps, 
> 						       NULL, 0, 0))
> 	            {
>                     status = 0;
>                     break;
> 		    }
> 	          break;
>           case 3: if (combineSeparateTileSamples24bits (srcbuffs, bufp, ncol, nrow,
>                                                        imagewidth, tw, spp, bps, 
> 						       NULL, 0, 0))
> 	            {
>                     status = 0;
>                     break;
>        	            }
>                   break;
>           case 4: 
>           case 5:
>           case 6:
>           case 7:
>           case 8: if (combineSeparateTileSamples32bits (srcbuffs, bufp, ncol, nrow,
>                                                        imagewidth, tw, spp, bps, 
> 						       NULL, 0, 0))
> 	            {
>                     status = 0;
>                     break;
> 		    }
> 	          break;
>           default: TIFFError ("readSeparateTilesIntoBuffer", "Unsupported bit depth: %d", bps);
>                   status = 0;
>                   break;
>           }
>         }
>       }
>     }
> 
>   for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)
>     {
>     tbuff = srcbuffs[sample];
>     if (tbuff != NULL)
>       _TIFFfree(tbuff);
>     }
>  
>   return status;
>   }
> 
> static int writeBufferToContigStrips(TIFF* out, uint8* buf, uint32 imagelength)
>   {
>   uint32 row, nrows, rowsperstrip;
>   tstrip_t strip = 0;
>   tsize_t stripsize;
> 
>   TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);
>   for (row = 0; row < imagelength; row += rowsperstrip)
>     {
>     nrows = (row + rowsperstrip > imagelength) ?
> 	     imagelength - row : rowsperstrip;
>     stripsize = TIFFVStripSize(out, nrows);
>     if (TIFFWriteEncodedStrip(out, strip++, buf, stripsize) < 0)
>       {
>       TIFFError(TIFFFileName(out), "Error, can't write strip %u", strip - 1);
>       return 0;
>       }
>     buf += stripsize;
>     }
> 
>   return 1;
>   }
875,878c1111,1117
< /* Function modified from original tiffcp version with plans to
<  * extend so that plannar orientation separate images do not have 
<  * all samples for each channel written before all sampels for the
<  * next channel. Current code is very similar in design to original.
---
> /* Abandon plans to modify code so that plannar orientation separate images
>  * do not have all samples for each channel written before all samples
>  * for the next channel have been abandoned.
>  * Libtiff internals seem to depend on all data for a given sample
>  * being contiguous within a strip or tile when PLANAR_CONFIG is 
>  * separate. All strips or tiles of a given plane are written
>  * before any strips or tiles of a different plane are stored.
916c1155
<       if (extractContigSamplesToBuffer(obuf, src, nrows, width, 0, 0, s, spp, bps, dump))
---
>       if (extractContigSamplesToBuffer(obuf, src, nrows, width, s, spp, bps, dump))
938,946c1177,1179
<   /*  Abandoning this code for now.  Would be nice to be able to write
<    *  one or more rows of each color to successive strips, rather than
<    *  all the rows of a given color before any rows of the next color.
< 
<   tsize_t row_buffsize;
<   row_buffsize = scanlinesize + (((spp + bps) + 7) / 8);
<   obuf = _TIFFmalloc (row_buffsize);
<   if (obuf == NULL)
<     return (0);
---
>   _TIFFfree(obuf);
>   return 1;
> }
947a1181,1200
> /* Extract all planes from contiguous buffer into a single tile buffer 
>  * to be written out as a tile.
>  */
> static int writeBufferToContigTiles (TIFF* out, uint8* buf, uint32 imagelength,
> 				       uint32 imagewidth, tsample_t spp, 
>                                        struct dump_opts* dump)
>   {
>   uint16 bps;
>   uint32 tl, tw;
>   uint32 row, col, nrow, ncol;
>   uint32 src_rowsize, col_offset;
>   uint32 tile_rowsize  = TIFFTileRowSize(out);
>   uint8* bufp = (uint8*) buf;
>   tsize_t tile_buffsize = 0;
>   tsize_t tilesize = TIFFTileSize(out);
>   unsigned char *tilebuf = NULL;
> 
>   TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);
>   TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);
>   TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);
949,950c1202,1218
<  TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip); 
<   for (row = 0; row < length; row++)
---
>   tile_buffsize = tilesize;
>   if (tilesize < (tsize_t)(tl * tile_rowsize))
>     {
> #ifdef DEBUG2
>     TIFFError("writeBufferToContigTiles",
> 	      "Tilesize %lu is too small, using alternate calculation %u",
>               tilesize, tl * tile_rowsize);
> #endif
>     tile_buffsize = tl * tile_rowsize;
>     }
> 
>   tilebuf = _TIFFmalloc(tile_buffsize);
>   if (tilebuf == 0)
>     return 0;
> 
>   src_rowsize = ((imagewidth * spp * bps) + 7) / 8;
>   for (row = 0; row < imagelength; row += tl)
952,954c1220,1221
<     src = buf + (row * rowsize);
<     total_bytes += scanlinesize;
<     for (s = 0; s < spp; s++)
---
>     nrow = (row + tl > imagelength) ? imagelength - row : tl;
>     for (col = 0; col < imagewidth; col += tw)
956,962c1223,1232
<       memset (obuf, '\0', row_buffsize);
<       if (extractContigSamplesToBuffer(obuf, src, 1, width, 0, 0, s, spp, bps, dump))
<         {
<         _TIFFfree(obuf);
<         return (0);
< 	}
<       if ((dump->outfile != NULL) && (dump->level == 1))
---
>       /* Calculate visible portion of tile. */
>       if (col + tw > imagewidth)
> 	ncol = imagewidth - col;
>       else
>         ncol = tw;
> 
>       col_offset = (((col * bps * spp) + 7) / 8);
>       bufp = buf + (row * src_rowsize) + col_offset;
>       if (extractContigSamplesToTileBuffer(tilebuf, bufp, nrow, ncol, imagewidth,
> 					   tw, 0, spp, spp, bps, dump) > 0)
964,968c1234,1239
<         dump_info(dump->outfile, dump->format,"", 
<                   "Row %4d, Sample %2d, bytes: %4d, Input offset: %6d", 
<                   row + 1, s + 1, scanlinesize, src - buf);
<         dump_buffer(dump->outfile, dump->format, nrows, scanlinesize, row, obuf);
< 	}
---
> 	TIFFError("writeBufferToContigTiles", 
>                   "Unable to extract data to tile for row %lu, col %lu",
>                   (unsigned long) row, (unsigned long)col);
> 	_TIFFfree(tilebuf);
> 	return (0);
>         }
970c1241
<       if (TIFFWriteScanline(out, obuf, row, s) < 0)
---
>       if (TIFFWriteTile(out, tilebuf, col, row, 0, 0) < 0)
972,973c1243,1246
< 	TIFFError(TIFFFileName(out), "Error, can't write scanline %lu", row + 1);
< 	_TIFFfree(obuf);
---
> 	TIFFError("writeBufferToContigTiles",
> 	          "Cannot write tile at %lu %lu",
> 	          (unsigned long) col, (unsigned long) row);
> 	 _TIFFfree(tilebuf);
977,978c1250,1251
<     } 
< */   
---
>     }
>   _TIFFfree(tilebuf);
980d1252
<   _TIFFfree(obuf);
982,1032c1254
< }
< 
< static int writeBufferToContigTiles (TIFF* out, uint8* buf, uint32 imagelength,
<                                      uint32 imagewidth, tsample_t spp)
< {
< 	uint32 imagew = TIFFScanlineSize(out);
< 	uint32 tilew  = TIFFTileRowSize(out);
< 	int iskew = imagew - tilew;
< 	tdata_t obuf = _TIFFmalloc(TIFFTileSize(out));
< 	uint8* bufp = (uint8*) buf;
< 	uint32 tl, tw;
< 	uint32 row;
< 
< 	(void) spp;
< 	if (obuf == NULL)
< 		return 0;
< 	(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);
< 	(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);
< 	for (row = 0; row < imagelength; row += tilelength) {
< 		uint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;
< 		uint32 colb = 0;
< 		uint32 col;
< 
< 		for (col = 0; col < imagewidth; col += tw) {
< 			/*
< 			 * Tile is clipped horizontally.  Calculate
< 			 * visible portion and skewing factors.
< 			 */
< 			if (colb + tilew > imagew) {
< 				uint32 width = imagew - colb;
< 				int oskew = tilew - width;
< 				cpStripToTile(obuf, bufp + colb, nrow, width,
< 				    oskew, oskew + iskew);
< 			} else
< 				cpStripToTile(obuf, bufp + colb, nrow, tilew,
< 				    0, iskew);
< 			if (TIFFWriteTile(out, obuf, col, row, 0, 0) < 0) {
< 				TIFFError(TIFFFileName(out),
< 					  "Error, can't write tile at %lu %lu",
< 					  (unsigned long) col,
< 					  (unsigned long) row);
< 				_TIFFfree(obuf);
< 				return 0;
< 			}
< 			colb += tilew;
< 		}
< 		bufp += nrow * imagew;
< 	}
< 	_TIFFfree(obuf);
< 	return 1;
< }
---
>   } /* end writeBufferToContigTiles */
1033a1256,1258
> /* Extract each plane from contiguous buffer into a single tile buffer 
>  * to be written out as a tile.
>  */
1038,1096c1263,1313
< 	uint32 imagew = TIFFScanlineSize(out);
< 	tsize_t tilew  = TIFFTileRowSize(out);
< 	uint32 iimagew = TIFFRasterScanlineSize(out);
< 	int iskew = iimagew - tilew*spp;
< 	tdata_t obuf = _TIFFmalloc(TIFFTileSize(out));
< 	uint8* bufp = (uint8*) buf;
< 	uint32 tl, tw;
< 	uint32 row;
<         uint16 bps, bytes_per_sample;
< 
< 	if (obuf == NULL)
< 		return 0;
< 	(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);
< 	(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);
< 	(void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);
<         assert( bps % 8 == 0 );
<         bytes_per_sample = (bps + 7)/8;
<         
< 	for (row = 0; row < imagelength; row += tl) {
< 		uint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;
< 		uint32 colb = 0;
< 		uint32 col;
< 
< 		for (col = 0; col < imagewidth; col += tw) {
< 			tsample_t s;
< 			for (s = 0; s < spp; s++) {
< 				/*
< 				 * Tile is clipped horizontally.  Calculate
< 				 * visible portion and skewing factors.
< 				 */
< 				if (colb + tilew > imagew) {
< 					uint32 width = (imagew - colb);
< 					int oskew = tilew - width;
< 
< 				  extractContigSamplesToBuffer(obuf,
< 					    bufp + (colb*spp) + s,
< 					    nrow, width/bytes_per_sample,
< 					    oskew, (oskew*spp)+iskew, s,
< 					    spp, bps, dump);
< 				} else
< 				    extractContigSamplesToBuffer(obuf,
< 					    bufp + (colb*spp) + s,
< 					    nrow, tilewidth,
< 					    0, iskew, s, spp,
< 					    bps, dump);
< 				if (TIFFWriteTile(out, obuf, col, row, 0, s) < 0) {
< 					TIFFError(TIFFFileName(out),
< 					"Error, can't write tile at %lu %lu "
< 					"sample %lu",
< 					(unsigned long) col,
< 					(unsigned long) row,
< 					(unsigned long) s);
< 					_TIFFfree(obuf);
< 					return 0;
< 				}
< 			}
< 			colb += tilew;
< 		}
< 		bufp += nrow * iimagew;
---
>   tdata_t obuf = _TIFFmalloc(TIFFTileSize(out));
>   uint32 tl, tw;
>   uint32 row, col, nrow, ncol;
>   uint32 src_rowsize, col_offset;
>   uint16 bps;
>   tsample_t s;
>   uint8* bufp = (uint8*) buf;
> 
>   if (obuf == NULL)
>     return 0;
> 
>   TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);
>   TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);
>   TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);
>   src_rowsize = ((imagewidth * spp * bps) + 7) / 8;
>          
>   for (row = 0; row < imagelength; row += tl)
>     {
>     nrow = (row + tl > imagelength) ? imagelength - row : tl;
>     for (col = 0; col < imagewidth; col += tw)
>       {
>       /* Calculate visible portion of tile. */
>       if (col + tw > imagewidth)
> 	ncol = imagewidth - col;
>       else
>         ncol = tw;
> 
>       col_offset = (((col * bps * spp) + 7) / 8);
>       bufp = buf + (row * src_rowsize) + col_offset;
> 
>       for (s = 0; s < spp; s++)
>         {
> 	if (extractContigSamplesToTileBuffer(obuf, bufp, nrow, ncol, imagewidth,
> 					     tw, s, 1, spp, bps, dump) > 0)
>           {
> 	  TIFFError("writeBufferToSeparateTiles", 
>                     "Unable to extract data to tile for row %lu, col %lu sample %d",
>                     (unsigned long) row, (unsigned long)col, (int)s);
> 	  _TIFFfree(obuf);
> 	  return (0);
>           }
> 
> 	if (TIFFWriteTile(out, obuf, col, row, 0, s) < 0)
>           {
> 	   TIFFError("writeBufferToseparateTiles",
> 	             "Cannot write tile at %lu %lu sample %lu",
> 	             (unsigned long) col, (unsigned long) row,
> 	             (unsigned long) s);
> 	   _TIFFfree(obuf);
> 	  return 0;
> 	  }
1098,1100c1315,1317
< 	_TIFFfree(obuf);
< 	return 1;
< }
---
>       }
>     }
>   _TIFFfree(obuf);
1101a1319,1320
>   return 1;
>   } /* end writeBufferToSeparateTiles */
1125,1141c1344,1345
< {
< 	if (streq(opt, "none")) {
< 		defcompression = COMPRESSION_NONE;
< 	} else if (streq(opt, "packbits")) {
< 		defcompression = COMPRESSION_PACKBITS;
< 	} else if (strneq(opt, "jpeg", 4)) {
< 		char* cp = strchr(opt, ':');
< 
<                 defcompression = COMPRESSION_JPEG;
<                 while( cp )
<                 {
<                     if (isdigit((int)cp[1]))
< 			quality = atoi(cp+1);
<                     else if (cp[1] == 'r' )
< 			jpegcolormode = JPEGCOLORMODE_RAW;
<                     else
<                         usage();
---
>   {
>   char* cp = NULL;
1143,1163c1347,1406
<                     cp = strchr(cp+1,':');
<                 }
< 	} else if (strneq(opt, "g3", 2)) {
< 		processG3Options(opt);
< 		defcompression = COMPRESSION_CCITTFAX3;
< 	} else if (streq(opt, "g4")) {
< 		defcompression = COMPRESSION_CCITTFAX4;
< 	} else if (strneq(opt, "lzw", 3)) {
< 		char* cp = strchr(opt, ':');
< 		if (cp)
< 			defpredictor = atoi(cp+1);
< 		defcompression = COMPRESSION_LZW;
< 	} else if (strneq(opt, "zip", 3)) {
< 		char* cp = strchr(opt, ':');
< 		if (cp)
< 			defpredictor = atoi(cp+1);
< 		defcompression = COMPRESSION_ADOBE_DEFLATE;
< 	} else
< 		return (0);
< 	return (1);
< }
---
>   if (strneq(opt, "none",4))
>     {
>     defcompression = COMPRESSION_NONE;
>     /* DELETE ME:  This should not be needed */
>     cp = strchr(opt, ':');
>     if (cp)
>       {
>       if (cp[1] == 'r' )
> 	jpegcolormode = JPEGCOLORMODE_RAW;
>       else if (cp[1] == 'a' )
> 	jpegcolormode = JPEGCOLORMODE_RGB;
>       }
>     /* end DELETE ME: */
>     }
>   else if (streq(opt, "packbits"))
>     {
>     defcompression = COMPRESSION_PACKBITS;
>     }
>   else if (strneq(opt, "jpeg", 4))
>     {
>     cp = strchr(opt, ':');
>     defcompression = COMPRESSION_JPEG;
>     while ( cp )
>       {
>       if (isdigit((int)cp[1]))
> 	quality = atoi(cp+1);
>       else if (cp[1] == 'r' )
> 	jpegcolormode = JPEGCOLORMODE_RAW;
>       else if (cp[1] == 'a' )
> 	jpegcolormode = JPEGCOLORMODE_RGB;
>       else
>         usage();
>       cp = strchr(cp+1,':');
>       }
>     }
>   else if (strneq(opt, "g3", 2))
>     {
>     processG3Options(opt);
>     defcompression = COMPRESSION_CCITTFAX3;
>     }
>   else if (streq(opt, "g4"))
>     {
>     defcompression = COMPRESSION_CCITTFAX4;
>     }
>   else if (strneq(opt, "lzw", 3))
>     {
>     cp = strchr(opt, ':');
>     if (cp)
>       defpredictor = atoi(cp+1);
>     defcompression = COMPRESSION_LZW;
>     }
>   else if (strneq(opt, "zip", 3))
>     {
>     cp = strchr(opt, ':');
>     if (cp)
>       defpredictor = atoi(cp+1);
>     defcompression = COMPRESSION_ADOBE_DEFLATE;
>    }
>   else
>     return (0);
1164a1408,1409
>   return (1);
>   }
1168,1170c1413,1415
< {
< 	char buf[BUFSIZ];
< 	int i;
---
>   {
>   char buf[BUFSIZ];
>   int i;
1172,1177c1417,1422
< 	setbuf(stderr, buf);
<         fprintf(stderr, "\n%s\n", TIFFGetVersion());
< 	for (i = 0; stuff[i] != NULL; i++)
< 		fprintf(stderr, "%s\n", stuff[i]);
< 	exit(-1);
< }
---
>   setbuf(stderr, buf);
>   fprintf(stderr, "\n%s\n", TIFFGetVersion());
>   for (i = 0; stuff[i] != NULL; i++)
>     fprintf(stderr, "%s\n", stuff[i]);
>   exit(-1);
>   }
1286,1299d1530
< static void
< cpStripToTile(uint8* out, uint8* in,
< 	uint32 rows, uint32 cols, int outskew, int inskew)
< {
< 	while (rows-- > 0) {
< 		uint32 j = cols;
< 		while (j-- > 0)
< 			*out++ = *in++;
< 		out += outskew;
< 		in += inskew;
< 	}
< }
< 
< 
1402c1633,1634
<       case 'v': TIFFError ("Tiffcrop version", "%s, last updated: %s", 
---
>       case 'v': TIFFError("Library Release", "%s", TIFFGetVersion());
>                 TIFFError ("Tiffcrop version", "%s, last updated: %s", 
1638c1870
< 			     imagelist[i++] = atoi(opt_ptr) - 1;
---
> 			     imagelist[i++] = atoi(opt_ptr);
1648c1880
< 			       imagelist[i++] = j - 1;
---
> 			       imagelist[i++] = j;
1857,1858c2089,2090
<   uint32 deftilewidth = (uint32) -1;
<   uint32 deftilelength = (uint32) -1;
---
>   uint32 deftilewidth = (uint32) 0;
>   uint32 deftilelength = (uint32) 0;
1861d2092
<   extern int   optind;
1984c2215
< 	    TIFFError ("Unable to open dump file %s for writing", "%s", temp_filename);
---
> 	    TIFFError ("Unable to open dump file for writing", "%s", temp_filename);
2000c2231
< 	    TIFFError ("Unable to open dump file %s for writing", "%s", temp_filename);
---
> 	      TIFFError ("Unable to open dump file for writing", "%s", temp_filename);
3273d3503
< 
3276,3277c3506,3507
<   	                     int outskew, int inskew, tsample_t sample,
<                              uint16 spp, uint16 bps, struct dump_opts *dump)
---
>   	                     tsample_t sample, uint16 spp, uint16 bps, 
>                              struct dump_opts *dump)
3318,3319c3548,3557
<       case 1: if (extractContigSamples8bits (src, dst, cols, sample,
<                                              spp, bps, count, first_col, cols))
---
>       case 1: if (bps == 1)
>                 {
>                 if (extractContigSamples8bits (src, dst, cols, sample,
>                                                spp, bps, count, first_col, cols))
> 	          return (1);
> 	        break;
> 		}
> 	      else
>                  if (extractContigSamples16bits (src, dst, cols, sample,
>                                                  spp, bps, count, first_col, cols))
3322c3560
<       case 2: if (extractContigSamples16bits (src, dst, cols, sample,
---
>       case 2: if (extractContigSamples24bits (src, dst, cols, sample,
3326,3329c3564
<       case 3: if (extractContigSamples24bits (src, dst, cols, sample,
<                                               spp, bps,  count, first_col, cols))
< 	         return (1);
<               break;
---
>       case 3:
3340,3342d3574
<     
<     out += outskew;
<     in += inskew;
3348,3352c3580,3583
< /* This will not work unless bps is a multiple of 8 */
< static void
< cpSeparateBufToContigBuf(uint8  *out, uint8 *in, uint32 rows, uint32 cols, 
<                          int outskew, int inskew, tsample_t spp,
<                          int bytes_per_sample)
---
> static int
> extractContigSamplesToTileBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols,
>   	                         uint32 imagewidth, uint32 tilewidth, tsample_t sample,
> 				 uint16 count, uint16 spp, uint16 bps, struct dump_opts *dump)
3354,3364c3585,3648
<   while (rows-- > 0)
<     {
<     uint32 j = cols;
<     while (j-- > 0)
<       {
<       int n = bytes_per_sample;
<       while( n-- )
<         {
<         *out++ = *in++;
<         }
<       out += (spp-1)*bytes_per_sample;
---
>   int    shift_width, bytes_per_sample, bytes_per_pixel;
>   uint32 src_rowsize, src_offset, row;
>   uint32 dst_rowsize, dst_offset;
>   uint8 *src, *dst;
> 
>   bytes_per_sample = (bps + 7) / 8; 
>   bytes_per_pixel  = ((bps * spp) + 7) / 8;
>   if ((bps % 8) == 0)
>     shift_width = 0;
>   else
>     {
>     if (bytes_per_pixel < (bytes_per_sample + 1))
>       shift_width = bytes_per_pixel;
>     else
>       shift_width = bytes_per_sample + 1;
>     }
> 
>   if ((dump->outfile != NULL) && (dump->level == 4))
>     {
>     dump_info  (dump->outfile, dump->format, "extractContigSamplesToTileBuffer", 
>                 "Sample %d, %d rows", sample + 1, rows + 1);
>     }
> 
>   src_rowsize = ((bps * spp * imagewidth) + 7) / 8;
>   dst_rowsize = ((bps * tilewidth * count) + 7) / 8;
> 
>   for (row = 0; row < rows; row++)
>     {
>     src_offset = row * src_rowsize;
>     dst_offset = row * dst_rowsize;
>     src = in + src_offset;
>     dst = out + dst_offset;
> 
>     /* pack the data into the scanline */
>     switch (shift_width)
>       {  
>       case 0: if (extractContigSamplesBytes (src, dst, cols, sample,
>                                              spp, bps,  count, 0, cols))  
>                 return (1);
>  	      break;
>       case 1: if (bps == 1)
>                 {
>                 if (extractContigSamples8bits (src, dst, cols, sample,
>                                                spp, bps, count, 0, cols))
> 	          return (1);
> 	        break;
> 		}
> 	      else
>                  if (extractContigSamples16bits (src, dst, cols, sample,
>                                                  spp, bps, count, 0, cols))
> 	         return (1);
> 	      break;
>       case 2: if (extractContigSamples24bits (src, dst, cols, sample,
>                                               spp, bps,  count, 0, cols))
> 	         return (1);
> 	      break;
>       case 3:
>       case 4: 
>       case 5: if (extractContigSamples32bits (src, dst, cols, sample,
>                                               spp, bps,  count, 0, cols))
> 	         return (1);
> 	      break;
>       default: TIFFError ("extractContigSamplesToTileBuffer", "Unsupported bit depth: %d", bps);
> 	       return (1);
3366,3367c3650,3651
<     out += outskew;
<     in += inskew;
---
>     if ((dump->outfile != NULL) && (dump->level == 4))
>       dump_buffer(dump->outfile, dump->format, 1, dst_rowsize, row, dst);
3369d3652
<   } /* end of cpSeparateBufToContifBuf */
3371,3372c3654,3658
< static int readContigStripsIntoBuffer (TIFF* in, uint8* buf, uint32 imagelength, 
<                                          uint32 imagewidth, tsample_t spp)
---
>   return (0);
>   } /* end extractContigSamplesToTileBuffer */
> 
> static int readContigStripsIntoBuffer (TIFF* in, uint8* buf, uint32 length, uint32 width, 
>                                        tsample_t spp, struct dump_opts * dump)
3374d3659
<   tsize_t scanlinesize = TIFFScanlineSize(in);
3376c3661,3674
<   uint32 row;
---
>   int32  bytes_read = 0;
>   uint16 nstrips   = TIFFNumberOfStrips(in);
>   uint32 stripsize = TIFFStripSize(in);
>   uint32 rows = 0, strip;
>   uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
>   tsize_t scanline_size = TIFFScanlineSize(in);
> 
>   for (strip = 0; strip < nstrips; strip++)
>     {
>     bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
>     rows = bytes_read / scanline_size;
>     if (bytes_read != (int32)stripsize)
>       TIFFError("", "Bytes read %lu does not match reported strip size %lu",
> 		(unsigned long) bytes_read, (unsigned long)stripsize);
3378,3389c3676,3683
<  (void) imagewidth; (void) spp;
<  for (row = 0; row < imagelength; row++)
<    {
<    if (TIFFReadScanline(in, (tdata_t) bufp, row, 0) < 0
< 	 && !ignore)
<      {
<      TIFFError(TIFFFileName(in),"Error, can't read scanline %lu",
< 	       (unsigned long) row);
<      return 0;
<      }
<    bufp += scanlinesize;
<    }
---
>     if (bytes_read < 0 && !ignore)
>       {
>       TIFFError("", "Error reading strip %lu after %lu rows",
> 		(unsigned long) strip, (unsigned long)rows);
>       return 0;
>       }
>     bufp += bytes_read;
>     }
3393a3688,3745
> static int 
> combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,
>                              uint32 cols, uint32 rows, uint16 spp, uint16 bps,
>                              FILE *dumpfile, int format, int level)
>   {
>   int i, bytes_per_sample;
>   uint32 row, col, col_offset, src_rowsize, dst_rowsize, row_offset;
>   unsigned char *src;
>   unsigned char *dst;
>   tsample_t s;
> 
>   src = srcbuffs[0];
>   dst = out;
>   if ((src == NULL) || (dst == NULL))
>     {
>     TIFFError("combineSeparateSamplesBytes","Invalid buffer address");
>     return (1);
>     }
> 
>   bytes_per_sample = (bps + 7) / 8; 
> 
>   src_rowsize = ((bps * cols) + 7) / 8;
>   dst_rowsize = ((bps * spp * cols) + 7) / 8;
>   for (row = 0; row < rows; row++)
>     {
>     if ((dumpfile != NULL) && (level == 2))
>       {
>       for (s = 0; s < spp; s++)
>         {
>         dump_info (dumpfile, format, "combineSeparateSamplesBytes","Input data, Sample %d", s);
>         dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize));
>         }
>       }
>     dst = out + (row * dst_rowsize);
>     row_offset = row * src_rowsize;
>     for (col = 0; col < cols; col++)
>       {
>       col_offset = row_offset + (col * (bps / 8)); 
>       for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)
>         {
>         src = srcbuffs[s] + col_offset; 
>         for (i = 0; i < bytes_per_sample; i++)
>           *(dst + i) = *(src + i);
>         src += bytes_per_sample;
>         dst += bytes_per_sample;
>         }   
>       }
> 
>     if ((dumpfile != NULL) && (level == 2))
>       {
>       dump_info (dumpfile, format, "combineSeparateSamplesBytes","Output data, combined samples");
>       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));
>       }
>     }
> 
>   return (0);
>   } /* end combineSeparateSamplesBytes */
> 
3395,3396c3747,3748
< combineSeparateSamples8bits (uint8 *in[], uint8 *out, uint32 row,
<                             uint32 cols, uint16 spp, uint16 bps, 
---
> combineSeparateSamples8bits (uint8 *in[], uint8 *out, uint32 cols,
>                             uint32 rows, uint16 spp, uint16 bps, 
3401c3753
<   uint32 dst_rowsize; 
---
>   uint32 src_rowsize, dst_rowsize, src_offset; 
3403c3755
<   uint32 col, src_byte = 0, src_bit = 0;
---
>   uint32 row, col, src_byte = 0, src_bit = 0;
3417a3770
>   src_rowsize = ((bps * cols) + 7) / 8;
3421,3424c3774
<   ready_bits = 0;
<   buff1 = buff2 = 0;
< 
<   for (col = 0; col < cols; col++)
---
>   for (row = 0; row < rows; row++)
3426,3433c3776,3780
<     /* Compute src byte(s) and bits within byte(s) */
<     bit_offset = col * bps;
<     src_byte = bit_offset / 8;
<     src_bit  = bit_offset % 8;
< 
<     matchbits = maskbits << (8 - src_bit - bps); 
<     /* load up next sample from each plane */
<     for (s = 0; s < spp; s++)
---
>     ready_bits = 0;
>     buff1 = buff2 = 0;
>     dst = out + (row * dst_rowsize);
>     src_offset = row * src_rowsize;
>     for (col = 0; col < cols; col++)
3435,3436c3782,3785
<       src = in[s] + src_byte;
<       buff1 = ((*src) & matchbits) << (src_bit);
---
>       /* Compute src byte(s) and bits within byte(s) */
>       bit_offset = col * bps;
>       src_byte = bit_offset / 8;
>       src_bit  = bit_offset % 8;
3438,3446c3787,3789
<       /* If we have a full buffer's worth, write it out */
<       if (ready_bits >= 8)
<         {
<         *dst++ = buff2;
<         buff2 = buff1;
<         ready_bits -= 8;
<         strcpy (action, "Flush");
<         }
<       else
---
>       matchbits = maskbits << (8 - src_bit - bps); 
>       /* load up next sample from each plane */
>       for (s = 0; s < spp; s++)
3448,3451c3791,3807
<         buff2 = (buff2 | (buff1 >> ready_bits));
<         strcpy (action, "Update");
<         }
<       ready_bits += bps;
---
> 	src = in[s] + src_offset + src_byte;
>         buff1 = ((*src) & matchbits) << (src_bit);
> 
>         /* If we have a full buffer's worth, write it out */
>         if (ready_bits >= 8)
>           {
>           *dst++ = buff2;
>           buff2 = buff1;
>           ready_bits -= 8;
>           strcpy (action, "Flush");
>           }
>         else
>           {
>           buff2 = (buff2 | (buff1 >> ready_bits));
>           strcpy (action, "Update");
>           }
>         ready_bits += bps;
3453,3455c3809,3811
<       if ((dumpfile != NULL) && (level == 3))
<         {
<         dump_info (dumpfile, format, "",
---
>         if ((dumpfile != NULL) && (level == 3))
>           {
>           dump_info (dumpfile, format, "",
3458,3463c3814,3820
<         dump_byte (dumpfile, format, "Match bits", matchbits);
<         dump_byte (dumpfile, format, "Src   bits", *src);
<         dump_byte (dumpfile, format, "Buff1 bits", buff1);
<         dump_byte (dumpfile, format, "Buff2 bits", buff2);
<         dump_info (dumpfile, format, "","%s", action); 
< 	}
---
>           dump_byte (dumpfile, format, "Match bits", matchbits);
>           dump_byte (dumpfile, format, "Src   bits", *src);
>           dump_byte (dumpfile, format, "Buff1 bits", buff1);
>           dump_byte (dumpfile, format, "Buff2 bits", buff2);
>           dump_info (dumpfile, format, "","%s", action); 
> 	  }
>         }
3465d3821
<     }
3467,3471c3823
<   if (ready_bits > 0)
<     {
<     buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));
<     *dst++ = buff1;
<     if ((dumpfile != NULL) && (level == 3))
---
>     if (ready_bits > 0)
3473c3825,3829
<       dump_info (dumpfile, format, "",
---
>       buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));
>       *dst++ = buff1;
>       if ((dumpfile != NULL) && (level == 3))
>         {
>         dump_info (dumpfile, format, "",
3476a3833
>         }
3478d3834
<     }
3480,3483c3836,3840
<   if ((dumpfile != NULL) && (level == 2))
<     {
<     dump_info (dumpfile, format, "combineSeparateSamples8bits","Output data");
<     dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);
---
>     if ((dumpfile != NULL) && (level >= 2))
>       {
>       dump_info (dumpfile, format, "combineSeparateSamples8bits","Output data");
>       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));
>       }
3485c3842
<   
---
> 
3490,3491c3847,3848
< combineSeparateSamples16bits (uint8 *in[], uint8 *out, uint32 row,
<                               uint32 cols, uint16 spp, uint16 bps, 
---
> combineSeparateSamples16bits (uint8 *in[], uint8 *out, uint32 cols,
>                               uint32 rows, uint16 spp, uint16 bps, 
3495,3497c3852,3854
<   uint32 dst_rowsize; 
<   uint32 bit_offset;
<   uint32 col, src_byte = 0, src_bit = 0;
---
>   uint32 src_rowsize, dst_rowsize; 
>   uint32 bit_offset, src_offset;
>   uint32 row, col, src_byte = 0, src_bit = 0;
3513a3871
>   src_rowsize = ((bps * cols) + 7) / 8;
3517,3519c3875
<   ready_bits = 0;
<   buff1 = buff2 = 0;
<   for (col = 0; col < cols; col++)
---
>   for (row = 0; row < rows; row++)
3521,3527c3877,3881
<     /* Compute src byte(s) and bits within byte(s) */
<     bit_offset = col * bps;
<     src_byte = bit_offset / 8;
<     src_bit  = bit_offset % 8;
< 
<     matchbits = maskbits << (16 - src_bit - bps); 
<     for (s = 0; s < spp; s++)
---
>     ready_bits = 0;
>     buff1 = buff2 = 0;
>     dst = out + (row * dst_rowsize);
>     src_offset = row * src_rowsize;
>     for (col = 0; col < cols; col++)
3529,3530c3883,3889
<       src = in[s] + src_byte;
<       if (little_endian)
---
>       /* Compute src byte(s) and bits within byte(s) */
>       bit_offset = col * bps;
>       src_byte = bit_offset / 8;
>       src_bit  = bit_offset % 8;
> 
>       matchbits = maskbits << (16 - src_bit - bps); 
>       for (s = 0; s < spp; s++)
3532,3535c3891,4007
<         swapbuff[1] = *src;
<         swapbuff[0] = *(src + 1);
<         }
<       else
---
> 	src = in[s] + src_offset + src_byte;
>         if (little_endian)
>           {
>           swapbuff[1] = *src;
>           swapbuff[0] = *(src + 1);
>           }
>         else
>           {
>           swapbuff[0] = *src;
>           swapbuff[1] = *(src + 1);
> 	  }
> 
> 	buff1 = *((uint16 *)swapbuff);
> 	buff1 = (buff1 & matchbits) << (src_bit);
> 
> 	/* If we have a full buffer's worth, write it out */
> 	if (ready_bits >= 8)
> 	  {
> 	    bytebuff = (buff2 >> 8);
> 	    *dst++ = bytebuff;
> 	    ready_bits -= 8;
> 	    /* shift in new bits */
> 	    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));
> 	    strcpy (action, "Flush");
> 	  }
> 	else
> 	  { /* add another bps bits to the buffer */
> 	    bytebuff = 0;
> 	    buff2 = (buff2 | (buff1 >> ready_bits));
> 	    strcpy (action, "Update");
> 	  }
> 	ready_bits += bps;
> 
> 	if ((dumpfile != NULL) && (level == 3))
> 	  {
> 	  dump_info (dumpfile, format, "",
> 		       "Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
> 		       row + 1, col + 1, s, src_byte, src_bit, dst - out);
> 
> 	  dump_short (dumpfile, format, "Match bits", matchbits);
> 	  dump_data  (dumpfile, format, "Src   bits", src, 2);
> 	  dump_short (dumpfile, format, "Buff1 bits", buff1);
> 	  dump_short (dumpfile, format, "Buff2 bits", buff2);
> 	  dump_byte  (dumpfile, format, "Write byte", bytebuff);
> 	  dump_info  (dumpfile, format, "","Ready bits:  %d, %s", ready_bits, action); 
> 	  }
> 	}
>       }
> 
>     /* catch any trailing bits at the end of the line */
>     if (ready_bits > 0)
>       {
>       bytebuff = (buff2 >> 8);
>       *dst++ = bytebuff;
>       if ((dumpfile != NULL) && (level == 3))
> 	{
> 	dump_info (dumpfile, format, "",
> 		       "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
> 		       row + 1, col + 1, src_byte, src_bit, dst - out);
> 	dump_byte (dumpfile, format, "Final bits", bytebuff);
> 	}
>       }
> 
>     if ((dumpfile != NULL) && (level == 2))
>       {
>       dump_info (dumpfile, format, "combineSeparateSamples16bits","Output data");
>       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));
>       }
>     }
> 
>   return (0);
>   } /* end combineSeparateSamples16bits */
> 
> static int
> combineSeparateSamples24bits (uint8 *in[], uint8 *out, uint32 cols,
>                               uint32 rows, uint16 spp, uint16 bps, 
> 	                      FILE *dumpfile, int format, int level)
>   {
>   int    ready_bits = 0, bytes_per_sample = 0;
>   uint32 src_rowsize, dst_rowsize; 
>   uint32 bit_offset, src_offset;
>   uint32 row, col, src_byte = 0, src_bit = 0;
>   uint32 maskbits = 0, matchbits = 0;
>   uint32 buff1 = 0, buff2 = 0;
>   uint8  bytebuff1 = 0, bytebuff2 = 0;
>   tsample_t s;
>   unsigned char *src = in[0];
>   unsigned char *dst = out;
>   unsigned char  swapbuff[4];
>   char           action[8];
> 
>   if ((src == NULL) || (dst == NULL))
>     {
>     TIFFError("combineSeparateSamples24bits","Invalid input or output buffer");
>     return (1);
>     }
> 
>   bytes_per_sample = (bps + 7) / 8; 
>   src_rowsize = ((bps * cols) + 7) / 8;
>   dst_rowsize = ((bps * cols * spp) + 7) / 8;
>   maskbits =  (uint32)-1 >> ( 32 - bps);
> 
>   for (row = 0; row < rows; row++)
>     {
>     ready_bits = 0;
>     buff1 = buff2 = 0;
>     dst = out + (row * dst_rowsize);
>     src_offset = row * src_rowsize;
>     for (col = 0; col < cols; col++)
>       {
>       /* Compute src byte(s) and bits within byte(s) */
>       bit_offset = col * bps;
>       src_byte = bit_offset / 8;
>       src_bit  = bit_offset % 8;
> 
>       matchbits = maskbits << (32 - src_bit - bps); 
>       for (s = 0; s < spp; s++)
3537,3538c4009,4061
<         swapbuff[0] = *src;
<         swapbuff[1] = *(src + 1);
---
> 	src = in[s] + src_offset + src_byte;
>         if (little_endian)
>           {
>           swapbuff[3] = *src;
>           swapbuff[2] = *(src + 1);
>           swapbuff[1] = *(src + 2);
>           swapbuff[0] = *(src + 3);
>           }
>         else
>           {
>           swapbuff[0] = *src;
>           swapbuff[1] = *(src + 1);
>           swapbuff[2] = *(src + 2);
>           swapbuff[3] = *(src + 3);
> 	  }
> 
> 	buff1 = *((uint32 *)swapbuff);
> 	buff1 = (buff1 & matchbits) << (src_bit);
> 
> 	/* If we have a full buffer's worth, write it out */
> 	if (ready_bits >= 16)
> 	  {
> 	    bytebuff1 = (buff2 >> 24);
> 	    *dst++ = bytebuff1;
> 	    bytebuff2 = (buff2 >> 16);
> 	    *dst++ = bytebuff2;
> 	    ready_bits -= 16;
> 
> 	    /* shift in new bits */
> 	    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));
> 	    strcpy (action, "Flush");
> 	  }
> 	else
> 	  { /* add another bps bits to the buffer */
> 	    bytebuff1 = bytebuff2 = 0;
> 	    buff2 = (buff2 | (buff1 >> ready_bits));
> 	    strcpy (action, "Update");
> 	  }
> 	ready_bits += bps;
> 
> 	if ((dumpfile != NULL) && (level == 3))
> 	  {
> 	  dump_info (dumpfile, format, "",
> 		       "Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
> 		       row + 1, col + 1, s, src_byte, src_bit, dst - out);
> 	  dump_long (dumpfile, format, "Match bits ", matchbits);
> 	  dump_data (dumpfile, format, "Src   bits ", src, 4);
> 	  dump_long (dumpfile, format, "Buff1 bits ", buff1);
> 	  dump_long (dumpfile, format, "Buff2 bits ", buff2);
> 	  dump_byte (dumpfile, format, "Write bits1", bytebuff1);
> 	  dump_byte (dumpfile, format, "Write bits2", bytebuff2);
> 	  dump_info (dumpfile, format, "","Ready bits:   %d, %s", ready_bits, action); 
> 	  }
3539a4063
>       }
3541,3542c4065,4069
<       buff1 = *((uint16 *)swapbuff);
<       buff1 = (buff1 & matchbits) << (src_bit);
---
>     /* catch any trailing bits at the end of the line */
>     while (ready_bits > 0)
>       {
> 	bytebuff1 = (buff2 >> 24);
> 	*dst++ = bytebuff1;
3544,3545c4071,4284
<       /* If we have a full buffer's worth, write it out */
<       if (ready_bits >= 8)
---
> 	buff2 = (buff2 << 8);
> 	bytebuff2 = bytebuff1;
> 	ready_bits -= 8;
>       }
>  
>     if ((dumpfile != NULL) && (level == 3))
>       {
>       dump_info (dumpfile, format, "",
> 		   "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
> 		   row + 1, col + 1, src_byte, src_bit, dst - out);
> 
>       dump_long (dumpfile, format, "Match bits ", matchbits);
>       dump_data (dumpfile, format, "Src   bits ", src, 4);
>       dump_long (dumpfile, format, "Buff1 bits ", buff1);
>       dump_long (dumpfile, format, "Buff2 bits ", buff2);
>       dump_byte (dumpfile, format, "Write bits1", bytebuff1);
>       dump_byte (dumpfile, format, "Write bits2", bytebuff2);
>       dump_info (dumpfile, format, "", "Ready bits:  %2d", ready_bits); 
>       }
> 
>     if ((dumpfile != NULL) && (level == 2))
>       {
>       dump_info (dumpfile, format, "combineSeparateSamples24bits","Output data");
>       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));
>       }
>     }
>   
>   return (0);
>   } /* end combineSeparateSamples24bits */
> 
> static int
> combineSeparateSamples32bits (uint8 *in[], uint8 *out, uint32 cols,
>                               uint32 rows, uint16 spp, uint16 bps, 
> 	                      FILE *dumpfile, int format, int level)
>   {
>   int    ready_bits = 0, bytes_per_sample = 0, shift_width = 0;
>   uint32 src_rowsize, dst_rowsize, bit_offset, src_offset;
>   uint32 src_byte = 0, src_bit = 0;
>   uint32 row, col;
>   uint32 longbuff1 = 0, longbuff2 = 0;
>   uint64 maskbits = 0, matchbits = 0;
>   uint64 buff1 = 0, buff2 = 0, buff3 = 0;
>   uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;
>   tsample_t s;
>   unsigned char *src = in[0];
>   unsigned char *dst = out;
>   unsigned char  swapbuff1[4];
>   unsigned char  swapbuff2[4];
>   char           action[8];
> 
>   if ((src == NULL) || (dst == NULL))
>     {
>     TIFFError("combineSeparateSamples32bits","Invalid input or output buffer");
>     return (1);
>     }
> 
>   bytes_per_sample = (bps + 7) / 8; 
>   src_rowsize = ((bps * cols) + 7) / 8;
>   dst_rowsize = ((bps * cols * spp) + 7) / 8;
>   maskbits =  (uint64)-1 >> ( 64 - bps);
>   shift_width = ((bps + 7) / 8) + 1; 
> 
>   for (row = 0; row < rows; row++)
>     {
>     ready_bits = 0;
>     buff1 = buff2 = 0;
>     dst = out + (row * dst_rowsize);
>     src_offset = row * src_rowsize;
>     for (col = 0; col < cols; col++)
>       {
>       /* Compute src byte(s) and bits within byte(s) */
>       bit_offset = col * bps;
>       src_byte = bit_offset / 8;
>       src_bit  = bit_offset % 8;
> 
>       matchbits = maskbits << (64 - src_bit - bps); 
>       for (s = 0; s < spp; s++)
> 	{
> 	src = in[s] + src_offset + src_byte;
> 	if (little_endian)
> 	  {
> 	  swapbuff1[3] = *src;
> 	  swapbuff1[2] = *(src + 1);
> 	  swapbuff1[1] = *(src + 2);
> 	  swapbuff1[0] = *(src + 3);
> 	  }
> 	else
> 	  {
> 	  swapbuff1[0] = *src;
> 	  swapbuff1[1] = *(src + 1);
> 	  swapbuff1[2] = *(src + 2);
> 	  swapbuff1[3] = *(src + 3);
> 	  }
>         longbuff1 = *((uint32 *)swapbuff1);                  
> 
> 	memset (swapbuff2, '\0', sizeof(swapbuff2));
> 	if (little_endian)
> 	  {
> 	  swapbuff2[3] = *src;
> 	  swapbuff2[2] = *(src + 1);
> 	  swapbuff2[1] = *(src + 2);
> 	  swapbuff2[0] = *(src + 3);
> 	  }
> 	else
> 	  {
> 	  swapbuff2[0] = *src;
> 	  swapbuff2[1] = *(src + 1);
> 	  swapbuff2[2] = *(src + 2);
> 	  swapbuff2[3] = *(src + 3);
> 	  }
> 
> 	longbuff2 = *((uint32 *)swapbuff2);
> 	buff3 = ((uint64)longbuff1 << 32) | longbuff2;
> 	buff1 = (buff3 & matchbits) << (src_bit);
> 
> 	/* If we have a full buffer's worth, write it out */
> 	if (ready_bits >= 32)
> 	  {
> 	  bytebuff1 = (buff2 >> 56);
> 	  *dst++ = bytebuff1;
> 	  bytebuff2 = (buff2 >> 48);
> 	  *dst++ = bytebuff2;
> 	  bytebuff3 = (buff2 >> 40);
> 	  *dst++ = bytebuff3;
> 	  bytebuff4 = (buff2 >> 32);
> 	  *dst++ = bytebuff4;
> 	  ready_bits -= 32;
>                     
> 	  /* shift in new bits */
> 	  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));
> 	  strcpy (action, "Flush");
> 	  }
> 	else
> 	  { /* add another bps bits to the buffer */
> 	  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;
> 	  buff2 = (buff2 | (buff1 >> ready_bits));
> 	  strcpy (action, "Update");
> 	  }
> 	ready_bits += bps;
> 
> 	if ((dumpfile != NULL) && (level == 3))
> 	  { 
> 	  dump_info (dumpfile, format, "",
> 		     "Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
> 		     row + 1, col + 1, s, src_byte, src_bit, dst - out);
> 	  dump_wide (dumpfile, format, "Match bits ", matchbits);
> 	  dump_data (dumpfile, format, "Src   bits ", src, 8);
> 	  dump_wide (dumpfile, format, "Buff1 bits ", buff1);
> 	  dump_wide (dumpfile, format, "Buff2 bits ", buff2);
> 	  dump_info (dumpfile, format, "", "Ready bits:   %d, %s", ready_bits, action); 
> 	  }
> 	}
>       }
>     while (ready_bits > 0)
>       {
>       bytebuff1 = (buff2 >> 56);
>       *dst++ = bytebuff1;
>       buff2 = (buff2 << 8);
>       ready_bits -= 8;
>       }
> 
>     if ((dumpfile != NULL) && (level == 3))
>       {
>       dump_info (dumpfile, format, "",
> 	         "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
> 		 row + 1, col + 1, src_byte, src_bit, dst - out);
> 
>       dump_long (dumpfile, format, "Match bits ", matchbits);
>       dump_data (dumpfile, format, "Src   bits ", src, 4);
>       dump_long (dumpfile, format, "Buff1 bits ", buff1);
>       dump_long (dumpfile, format, "Buff2 bits ", buff2);
>       dump_byte (dumpfile, format, "Write bits1", bytebuff1);
>       dump_byte (dumpfile, format, "Write bits2", bytebuff2);
>       dump_info (dumpfile, format, "", "Ready bits:  %2d", ready_bits); 
>       }
> 
>     if ((dumpfile != NULL) && (level == 2))
>       {
>       dump_info (dumpfile, format, "combineSeparateSamples32bits","Output data");
>       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);
>       }
>     }
>   
>   return (0);
>   } /* end combineSeparateSamples32bits */
> 
> static int 
> combineSeparateTileSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,
>                                  uint32 cols, uint32 rows, uint32 imagewidth,
>                                  uint32 tw, uint16 spp, uint16 bps,
>                                  FILE *dumpfile, int format, int level)
>   {
>   int i, bytes_per_sample;
>   uint32 row, col, col_offset, src_rowsize, dst_rowsize, src_offset;
>   unsigned char *src;
>   unsigned char *dst;
>   tsample_t s;
> 
>   src = srcbuffs[0];
>   dst = out;
>   if ((src == NULL) || (dst == NULL))
>     {
>     TIFFError("combineSeparateTileSamplesBytes","Invalid buffer address");
>     return (1);
>     }
> 
>   bytes_per_sample = (bps + 7) / 8; 
>   src_rowsize = ((bps * tw) + 7) / 8;
>   dst_rowsize = imagewidth * bytes_per_sample * spp;
>   for (row = 0; row < rows; row++)
>     {
>     if ((dumpfile != NULL) && (level == 2))
>       {
>       for (s = 0; s < spp; s++)
3547,3552c4286,4287
<         bytebuff = (buff2 >> 8);
<         *dst++ = bytebuff;
<         ready_bits -= 8;
<         /* shift in new bits */
<         buff2 = ((buff2 << 8) | (buff1 >> ready_bits));
<         strcpy (action, "Flush");
---
>         dump_info (dumpfile, format, "combineSeparateTileSamplesBytes","Input data, Sample %d", s);
>         dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize));
3554,3558c4289,4390
<       else
<         { /* add another bps bits to the buffer */
<         bytebuff = 0;
<         buff2 = (buff2 | (buff1 >> ready_bits));
<         strcpy (action, "Update");
---
>       }
>     dst = out + (row * dst_rowsize);
>     src_offset = row * src_rowsize;
> #ifdef DEVELMODE
>     TIFFError("","Tile row %4d, Src offset %6d   Dst offset %6d", 
>               row, src_offset, dst - out);
> #endif
>     for (col = 0; col < cols; col++)
>       {
>       col_offset = src_offset + (col * (bps / 8)); 
>       for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)
>         {
>         src = srcbuffs[s] + col_offset; 
>         for (i = 0; i < bytes_per_sample; i++)
>           *(dst + i) = *(src + i);
>         dst += bytes_per_sample;
>         }   
>       }
> 
>     if ((dumpfile != NULL) && (level == 2))
>       {
>       dump_info (dumpfile, format, "combineSeparateTileSamplesBytes","Output data, combined samples");
>       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));
>       }
>     }
> 
>   return (0);
>   } /* end combineSeparateTileSamplesBytes */
> 
> static int
> combineSeparateTileSamples8bits (uint8 *in[], uint8 *out, uint32 cols,
>                                  uint32 rows, uint32 imagewidth, 
>                                  uint32 tw, uint16 spp, uint16 bps, 
>  	                         FILE *dumpfile, int format, int level)
>   {
>   int    ready_bits = 0;
>   uint32 src_rowsize, dst_rowsize, src_offset; 
>   uint32 bit_offset;
>   uint32 row, col, src_byte = 0, src_bit = 0;
>   uint8  maskbits = 0, matchbits = 0;
>   uint8  buff1 = 0, buff2 = 0;
>   tsample_t s;
>   unsigned char *src = in[0];
>   unsigned char *dst = out;
>   char           action[32];
> 
>   if ((src == NULL) || (dst == NULL))
>     {
>     TIFFError("combineSeparateTileSamples8bits","Invalid input or output buffer");
>     return (1);
>     }
> 
>   src_rowsize = ((bps * tw) + 7) / 8;
>   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;
>   maskbits =  (uint8)-1 >> ( 8 - bps);
> 
>   for (row = 0; row < rows; row++)
>     {
>     ready_bits = 0;
>     buff1 = buff2 = 0;
>     dst = out + (row * dst_rowsize);
>     src_offset = row * src_rowsize;
>     for (col = 0; col < cols; col++)
>       {
>       /* Compute src byte(s) and bits within byte(s) */
>       bit_offset = col * bps;
>       src_byte = bit_offset / 8;
>       src_bit  = bit_offset % 8;
> 
>       matchbits = maskbits << (8 - src_bit - bps); 
>       /* load up next sample from each plane */
>       for (s = 0; s < spp; s++)
>         {
> 	src = in[s] + src_offset + src_byte;
>         buff1 = ((*src) & matchbits) << (src_bit);
> 
>         /* If we have a full buffer's worth, write it out */
>         if (ready_bits >= 8)
>           {
>           *dst++ = buff2;
>           buff2 = buff1;
>           ready_bits -= 8;
>           strcpy (action, "Flush");
>           }
>         else
>           {
>           buff2 = (buff2 | (buff1 >> ready_bits));
>           strcpy (action, "Update");
>           }
>         ready_bits += bps;
>  
>         if ((dumpfile != NULL) && (level == 3))
>           {
>           dump_info (dumpfile, format, "",
>                    "Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
> 		   row + 1, col + 1, s, src_byte, src_bit, dst - out);
>           dump_byte (dumpfile, format, "Match bits", matchbits);
>           dump_byte (dumpfile, format, "Src   bits", *src);
>           dump_byte (dumpfile, format, "Buff1 bits", buff1);
>           dump_byte (dumpfile, format, "Buff2 bits", buff2);
>           dump_info (dumpfile, format, "","%s", action); 
> 	  }
3560c4392
<       ready_bits += bps;
---
>       }
3561a4394,4397
>     if (ready_bits > 0)
>       {
>       buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));
>       *dst++ = buff1;
3565,3566c4401,4509
< 	    "Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
< 	    row + 1, col + 1, s, src_byte, src_bit, dst - out);
---
> 	         "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
> 	         row + 1, col + 1, src_byte, src_bit, dst - out);
>                  dump_byte (dumpfile, format, "Final bits", buff1);
>         }
>       }
> 
>     if ((dumpfile != NULL) && (level >= 2))
>       {
>       dump_info (dumpfile, format, "combineSeparateTileSamples8bits","Output data");
>       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));
>       }
>     }
> 
>   return (0);
>   } /* end combineSeparateTileSamples8bits */
> 
> static int
> combineSeparateTileSamples16bits (uint8 *in[], uint8 *out, uint32 cols,
>                                   uint32 rows, uint32 imagewidth, 
>                                   uint32 tw, uint16 spp, uint16 bps, 
>  	                          FILE *dumpfile, int format, int level)
>   {
>   int    ready_bits = 0;
>   uint32 src_rowsize, dst_rowsize; 
>   uint32 bit_offset, src_offset;
>   uint32 row, col, src_byte = 0, src_bit = 0;
>   uint16 maskbits = 0, matchbits = 0;
>   uint16 buff1 = 0, buff2 = 0;
>   uint8  bytebuff = 0;
>   tsample_t s;
>   unsigned char *src = in[0];
>   unsigned char *dst = out;
>   unsigned char  swapbuff[2];
>   char           action[8];
> 
>   if ((src == NULL) || (dst == NULL))
>     {
>     TIFFError("combineSeparateTileSamples16bits","Invalid input or output buffer");
>     return (1);
>     }
> 
>   src_rowsize = ((bps * tw) + 7) / 8;
>   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;
>   maskbits = (uint16)-1 >> (16 - bps);
> 
>   for (row = 0; row < rows; row++)
>     {
>     ready_bits = 0;
>     buff1 = buff2 = 0;
>     dst = out + (row * dst_rowsize);
>     src_offset = row * src_rowsize;
>     for (col = 0; col < cols; col++)
>       {
>       /* Compute src byte(s) and bits within byte(s) */
>       bit_offset = col * bps;
>       src_byte = bit_offset / 8;
>       src_bit  = bit_offset % 8;
> 
>       matchbits = maskbits << (16 - src_bit - bps); 
>       for (s = 0; s < spp; s++)
>         {
> 	src = in[s] + src_offset + src_byte;
>         if (little_endian)
>           {
>           swapbuff[1] = *src;
>           swapbuff[0] = *(src + 1);
>           }
>         else
>           {
>           swapbuff[0] = *src;
>           swapbuff[1] = *(src + 1);
> 	  }
> 
> 	buff1 = *((uint16 *)swapbuff);
> 	buff1 = (buff1 & matchbits) << (src_bit);
> 
> 	/* If we have a full buffer's worth, write it out */
> 	if (ready_bits >= 8)
> 	  {
> 	    bytebuff = (buff2 >> 8);
> 	    *dst++ = bytebuff;
> 	    ready_bits -= 8;
> 	    /* shift in new bits */
> 	    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));
> 	    strcpy (action, "Flush");
> 	  }
> 	else
> 	  { /* add another bps bits to the buffer */
> 	    bytebuff = 0;
> 	    buff2 = (buff2 | (buff1 >> ready_bits));
> 	    strcpy (action, "Update");
> 	  }
> 	ready_bits += bps;
> 
> 	if ((dumpfile != NULL) && (level == 3))
> 	  {
> 	  dump_info (dumpfile, format, "",
> 		       "Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
> 		       row + 1, col + 1, s, src_byte, src_bit, dst - out);
> 
> 	  dump_short (dumpfile, format, "Match bits", matchbits);
> 	  dump_data  (dumpfile, format, "Src   bits", src, 2);
> 	  dump_short (dumpfile, format, "Buff1 bits", buff1);
> 	  dump_short (dumpfile, format, "Buff2 bits", buff2);
> 	  dump_byte  (dumpfile, format, "Write byte", bytebuff);
> 	  dump_info  (dumpfile, format, "","Ready bits:  %d, %s", ready_bits, action); 
> 	  }
> 	}
>       }
3568,3574c4511,4522
<         dump_short (dumpfile, format, "Match bits", matchbits);
<         dump_data  (dumpfile, format, "Src   bits", src, 2);
<         dump_short (dumpfile, format, "Buff1 bits", buff1);
<         dump_short (dumpfile, format, "Buff2 bits", buff2);
<         dump_byte  (dumpfile, format, "Write byte", bytebuff);
<         dump_info  (dumpfile, format, "","Ready bits:  %d, %s", ready_bits, action); 
<         }
---
>     /* catch any trailing bits at the end of the line */
>     if (ready_bits > 0)
>       {
>       bytebuff = (buff2 >> 8);
>       *dst++ = bytebuff;
>       if ((dumpfile != NULL) && (level == 3))
> 	{
> 	dump_info (dumpfile, format, "",
> 		       "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
> 		       row + 1, col + 1, src_byte, src_bit, dst - out);
> 	dump_byte (dumpfile, format, "Final bits", bytebuff);
> 	}
3576,3582c4524,4525
<     }
<   /* catch any trailing bits at the end of the line */
<   if (ready_bits > 0)
<     {
<     bytebuff = (buff2 >> 8);
<     *dst++ = bytebuff;
<     if ((dumpfile != NULL) && (level == 3))
---
> 
>     if ((dumpfile != NULL) && (level == 2))
3584,3587c4527,4528
<       dump_info (dumpfile, format, "",
< 	  "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
< 	  row + 1, col + 1, src_byte, src_bit, dst - out);
<       dump_byte (dumpfile, format, "Final bits", bytebuff);
---
>       dump_info (dumpfile, format, "combineSeparateTileSamples16bits","Output data");
>       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));
3591,3596d4531
<   if ((dumpfile != NULL) && (level == 2))
<     {
<     dump_info (dumpfile, format, "combineSeparateSamples16bits","Output data");
<     dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);
<     }
<   
3598c4533
<   } /* end combineSeparateSamples16bits */
---
>   } /* end combineSeparateTileSamples16bits */
3601,3603c4536,4539
< combineSeparateSamples24bits (uint8 *in[], uint8 *out, uint32 row,
<                               uint32 cols, uint16 spp, uint16 bps, 
< 	                      FILE *dumpfile, int format, int level)
---
> combineSeparateTileSamples24bits (uint8 *in[], uint8 *out, uint32 cols,
>                                   uint32 rows, uint32 imagewidth, 
>                                   uint32 tw, uint16 spp, uint16 bps, 
>  	                          FILE *dumpfile, int format, int level)
3605,3608c4541,4544
<   int    ready_bits = 0, bytes_per_sample = 0;
<   uint32 dst_rowsize; 
<   uint32 bit_offset;
<   uint32 col, src_byte = 0, src_bit = 0;
---
>   int    ready_bits = 0;
>   uint32 src_rowsize, dst_rowsize; 
>   uint32 bit_offset, src_offset;
>   uint32 row, col, src_byte = 0, src_bit = 0;
3620c4556
<     TIFFError("combineSeparateSamples24bits","Invalid input or output buffer");
---
>     TIFFError("combineSeparateTileSamples24bits","Invalid input or output buffer");
3624,3625c4560,4561
<   bytes_per_sample = (bps + 7) / 8; 
<   dst_rowsize = ((bps * cols) + 7) / 8;
---
>   src_rowsize = ((bps * tw) + 7) / 8;
>   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;
3628,3630c4564
<   ready_bits = 0;
<   buff1 = buff2 = 0;
<   for (col = 0; col < cols; col++)
---
>   for (row = 0; row < rows; row++)
3632,3638c4566,4570
<     /* Compute src byte(s) and bits within byte(s) */
<     bit_offset = col * bps;
<     src_byte = bit_offset / 8;
<     src_bit  = bit_offset % 8;
< 
<     matchbits = maskbits << (32 - src_bit - bps); 
<     for (s = 0; s < spp; s++)
---
>     ready_bits = 0;
>     buff1 = buff2 = 0;
>     dst = out + (row * dst_rowsize);
>     src_offset = row * src_rowsize;
>     for (col = 0; col < cols; col++)
3640,3657c4572,4575
<       src = in[s] + src_byte;
<       if (little_endian)
<         {
<         swapbuff[3] = *src;
<         swapbuff[2] = *(src + 1);
<         swapbuff[1] = *(src + 2);
<         swapbuff[0] = *(src + 3);
<         }
<       else
<         {
<         swapbuff[0] = *src;
<         swapbuff[1] = *(src + 1);
<         swapbuff[2] = *(src + 2);
<         swapbuff[3] = *(src + 3);
< 	}
< 
<       buff1 = *((uint32 *)swapbuff);
<       buff1 = (buff1 & matchbits) << (src_bit);
---
>       /* Compute src byte(s) and bits within byte(s) */
>       bit_offset = col * bps;
>       src_byte = bit_offset / 8;
>       src_bit  = bit_offset % 8;
3659,3660c4577,4578
<       /* If we have a full buffer's worth, write it out */
<       if (ready_bits >= 16)
---
>       matchbits = maskbits << (32 - src_bit - bps); 
>       for (s = 0; s < spp; s++)
3662,3666c4580,4594
<         bytebuff1 = (buff2 >> 24);
<         *dst++ = bytebuff1;
<         bytebuff2 = (buff2 >> 16);
<         *dst++ = bytebuff2;
<         ready_bits -= 16;
---
> 	src = in[s] + src_offset + src_byte;
>         if (little_endian)
>           {
>           swapbuff[3] = *src;
>           swapbuff[2] = *(src + 1);
>           swapbuff[1] = *(src + 2);
>           swapbuff[0] = *(src + 3);
>           }
>         else
>           {
>           swapbuff[0] = *src;
>           swapbuff[1] = *(src + 1);
>           swapbuff[2] = *(src + 2);
>           swapbuff[3] = *(src + 3);
> 	  }
3668,3678c4596,4597
<         /* shift in new bits */
<         buff2 = ((buff2 << 16) | (buff1 >> ready_bits));
<         strcpy (action, "Flush");
<         }
<       else
<         { /* add another bps bits to the buffer */
<         bytebuff1 = bytebuff2 = 0;
<         buff2 = (buff2 | (buff1 >> ready_bits));
<         strcpy (action, "Update");
<         }
<       ready_bits += bps;
---
> 	buff1 = *((uint32 *)swapbuff);
> 	buff1 = (buff1 & matchbits) << (src_bit);
3680,3692c4599,4633
<       if ((dumpfile != NULL) && (level == 3))
<         {
<         dump_info (dumpfile, format, "",
< 	        "Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
< 		   row + 1, col + 1, s, src_byte, src_bit, dst - out);
<         dump_long (dumpfile, format, "Match bits ", matchbits);
<         dump_data (dumpfile, format, "Src   bits ", src, 4);
<         dump_long (dumpfile, format, "Buff1 bits ", buff1);
<         dump_long (dumpfile, format, "Buff2 bits ", buff2);
<         dump_byte (dumpfile, format, "Write bits1", bytebuff1);
<         dump_byte (dumpfile, format, "Write bits2", bytebuff2);
<         dump_info (dumpfile, format, "","Ready bits:   %d, %s", ready_bits, action); 
<         }
---
> 	/* If we have a full buffer's worth, write it out */
> 	if (ready_bits >= 16)
> 	  {
> 	    bytebuff1 = (buff2 >> 24);
> 	    *dst++ = bytebuff1;
> 	    bytebuff2 = (buff2 >> 16);
> 	    *dst++ = bytebuff2;
> 	    ready_bits -= 16;
> 
> 	    /* shift in new bits */
> 	    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));
> 	    strcpy (action, "Flush");
> 	  }
> 	else
> 	  { /* add another bps bits to the buffer */
> 	    bytebuff1 = bytebuff2 = 0;
> 	    buff2 = (buff2 | (buff1 >> ready_bits));
> 	    strcpy (action, "Update");
> 	  }
> 	ready_bits += bps;
> 
> 	if ((dumpfile != NULL) && (level == 3))
> 	  {
> 	  dump_info (dumpfile, format, "",
> 		       "Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
> 		       row + 1, col + 1, s, src_byte, src_bit, dst - out);
> 	  dump_long (dumpfile, format, "Match bits ", matchbits);
> 	  dump_data (dumpfile, format, "Src   bits ", src, 4);
> 	  dump_long (dumpfile, format, "Buff1 bits ", buff1);
> 	  dump_long (dumpfile, format, "Buff2 bits ", buff2);
> 	  dump_byte (dumpfile, format, "Write bits1", bytebuff1);
> 	  dump_byte (dumpfile, format, "Write bits2", bytebuff2);
> 	  dump_info (dumpfile, format, "","Ready bits:   %d, %s", ready_bits, action); 
> 	  }
> 	}
3694d4634
<     }
3696,3700c4636,4640
<   /* catch any trailing bits at the end of the line */
<   while (ready_bits > 0)
<     {
<     bytebuff1 = (buff2 >> 24);
<     *dst++ = bytebuff1;
---
>     /* catch any trailing bits at the end of the line */
>     while (ready_bits > 0)
>       {
> 	bytebuff1 = (buff2 >> 24);
> 	*dst++ = bytebuff1;
3702,3705c4642,4645
<     buff2 = (buff2 << 8);
<     bytebuff2 = bytebuff1;
<     ready_bits -= 8;
<     }
---
> 	buff2 = (buff2 << 8);
> 	bytebuff2 = bytebuff1;
> 	ready_bits -= 8;
>       }
3707,3711c4647,4651
<   if ((dumpfile != NULL) && (level == 3))
<     {
<     dump_info (dumpfile, format, "",
<       "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
<       row + 1, col + 1, src_byte, src_bit, dst - out);
---
>     if ((dumpfile != NULL) && (level == 3))
>       {
>       dump_info (dumpfile, format, "",
> 		   "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
> 		   row + 1, col + 1, src_byte, src_bit, dst - out);
3713,3720c4653,4660
<     dump_long (dumpfile, format, "Match bits ", matchbits);
<     dump_data (dumpfile, format, "Src   bits ", src, 4);
<     dump_long (dumpfile, format, "Buff1 bits ", buff1);
<     dump_long (dumpfile, format, "Buff2 bits ", buff2);
<     dump_byte (dumpfile, format, "Write bits1", bytebuff1);
<     dump_byte (dumpfile, format, "Write bits2", bytebuff2);
<     dump_info (dumpfile, format, "", "Ready bits:  %2d", ready_bits); 
<     }
---
>       dump_long (dumpfile, format, "Match bits ", matchbits);
>       dump_data (dumpfile, format, "Src   bits ", src, 4);
>       dump_long (dumpfile, format, "Buff1 bits ", buff1);
>       dump_long (dumpfile, format, "Buff2 bits ", buff2);
>       dump_byte (dumpfile, format, "Write bits1", bytebuff1);
>       dump_byte (dumpfile, format, "Write bits2", bytebuff2);
>       dump_info (dumpfile, format, "", "Ready bits:  %2d", ready_bits); 
>       }
3722,3725c4662,4666
<   if ((dumpfile != NULL) && (level == 2))
<     {
<     dump_info (dumpfile, format, "combineSeparateSamples24bits","Output data");
<     dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);
---
>     if ((dumpfile != NULL) && (level == 2))
>       {
>       dump_info (dumpfile, format, "combineSeparateTileSamples24bits","Output data");
>       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));
>       }
3729c4670
<   } /* end combineSeparateSamples24bits */
---
>   } /* end combineSeparateTileSamples24bits */
3732,3734c4673,4676
< combineSeparateSamples32bits (uint8 *in[], uint8 *out, uint32 row,
<                               uint32 cols, uint16 spp, uint16 bps, 
< 	                      FILE *dumpfile, int format, int level)
---
> combineSeparateTileSamples32bits (uint8 *in[], uint8 *out, uint32 cols,
>                                   uint32 rows, uint32 imagewidth, 
>                                   uint32 tw, uint16 spp, uint16 bps, 
>  	                          FILE *dumpfile, int format, int level)
3736,3738c4678,4679
<   int    ready_bits = 0, bytes_per_sample = 0, shift_width = 0;
<   uint32 dst_rowsize; 
<   uint32 bit_offset;
---
>   int    ready_bits = 0, shift_width = 0;
>   uint32 src_rowsize, dst_rowsize, bit_offset, src_offset;
3740c4681
<   uint32 col;
---
>   uint32 row, col;
3754c4695
<     TIFFError("combineSeparateSamples32bits","Invalid input or output buffer");
---
>     TIFFError("combineSeparateTileSamples32bits","Invalid input or output buffer");
3758,3759c4699,4700
<   bytes_per_sample = (bps + 7) / 8; 
<   dst_rowsize = ((bps * cols) + 7) / 8;
---
>   src_rowsize = ((bps * tw) + 7) / 8;
>   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;
3763,3765c4704
<   ready_bits = 0;
<   buff1 = buff2 = 0;
<   for (col = 0; col < cols; col++)
---
>   for (row = 0; row < rows; row++)
3767,3773c4706,4710
<     /* Compute src byte(s) and bits within byte(s) */
<     bit_offset = col * bps;
<     src_byte = bit_offset / 8;
<     src_bit  = bit_offset % 8;
< 
<     matchbits = maskbits << (64 - src_bit - bps); 
<     for (s = 0; s < spp; s++)
---
>     ready_bits = 0;
>     buff1 = buff2 = 0;
>     dst = out + (row * dst_rowsize);
>     src_offset = row * src_rowsize;
>     for (col = 0; col < cols; col++)
3775,3790c4712,4715
<       src = in[s] + src_byte;
<       if (little_endian)
<         {
<         swapbuff1[3] = *src;
<         swapbuff1[2] = *(src + 1);
<         swapbuff1[1] = *(src + 2);
<         swapbuff1[0] = *(src + 3);
<         }
<       else
<         {
<         swapbuff1[0] = *src;
<         swapbuff1[1] = *(src + 1);
<         swapbuff1[2] = *(src + 2);
<         swapbuff1[3] = *(src + 3);
< 	}
<       longbuff1 = *((uint32 *)swapbuff1);                  
---
>       /* Compute src byte(s) and bits within byte(s) */
>       bit_offset = col * bps;
>       src_byte = bit_offset / 8;
>       src_bit  = bit_offset % 8;
3792,3806c4717,4735
<       memset (swapbuff2, '\0', sizeof(swapbuff2));
<       if (little_endian)
<         {
<         swapbuff2[3] = *src;
<         swapbuff2[2] = *(src + 1);
<         swapbuff2[1] = *(src + 2);
<         swapbuff2[0] = *(src + 3);
<         }
<       else
<         {
<         swapbuff2[0] = *src;
<         swapbuff2[1] = *(src + 1);
<         swapbuff2[2] = *(src + 2);
<         swapbuff2[3] = *(src + 3);
< 	}
---
>       matchbits = maskbits << (64 - src_bit - bps); 
>       for (s = 0; s < spp; s++)
> 	{
> 	src = in[s] + src_offset + src_byte;
> 	if (little_endian)
> 	  {
> 	  swapbuff1[3] = *src;
> 	  swapbuff1[2] = *(src + 1);
> 	  swapbuff1[1] = *(src + 2);
> 	  swapbuff1[0] = *(src + 3);
> 	  }
> 	else
> 	  {
> 	  swapbuff1[0] = *src;
> 	  swapbuff1[1] = *(src + 1);
> 	  swapbuff1[2] = *(src + 2);
> 	  swapbuff1[3] = *(src + 3);
> 	  }
>         longbuff1 = *((uint32 *)swapbuff1);                  
3808,3810c4737,4751
<       longbuff2 = *((uint32 *)swapbuff2);
<       buff3 = ((uint64)longbuff1 << 32) | longbuff2;
<       buff1 = (buff3 & matchbits) << (src_bit);
---
> 	memset (swapbuff2, '\0', sizeof(swapbuff2));
> 	if (little_endian)
> 	  {
> 	  swapbuff2[3] = *src;
> 	  swapbuff2[2] = *(src + 1);
> 	  swapbuff2[1] = *(src + 2);
> 	  swapbuff2[0] = *(src + 3);
> 	  }
> 	else
> 	  {
> 	  swapbuff2[0] = *src;
> 	  swapbuff2[1] = *(src + 1);
> 	  swapbuff2[2] = *(src + 2);
> 	  swapbuff2[3] = *(src + 3);
> 	  }
3812,3823c4753,4768
<       /* If we have a full buffer's worth, write it out */
<       if (ready_bits >= 32)
<         {
<         bytebuff1 = (buff2 >> 56);
<         *dst++ = bytebuff1;
<         bytebuff2 = (buff2 >> 48);
<         *dst++ = bytebuff2;
<         bytebuff3 = (buff2 >> 40);
<         *dst++ = bytebuff3;
<         bytebuff4 = (buff2 >> 32);
<         *dst++ = bytebuff4;
<         ready_bits -= 32;
---
> 	longbuff2 = *((uint32 *)swapbuff2);
> 	buff3 = ((uint64)longbuff1 << 32) | longbuff2;
> 	buff1 = (buff3 & matchbits) << (src_bit);
> 
> 	/* If we have a full buffer's worth, write it out */
> 	if (ready_bits >= 32)
> 	  {
> 	  bytebuff1 = (buff2 >> 56);
> 	  *dst++ = bytebuff1;
> 	  bytebuff2 = (buff2 >> 48);
> 	  *dst++ = bytebuff2;
> 	  bytebuff3 = (buff2 >> 40);
> 	  *dst++ = bytebuff3;
> 	  bytebuff4 = (buff2 >> 32);
> 	  *dst++ = bytebuff4;
> 	  ready_bits -= 32;
3825,3835c4770,4780
<         /* shift in new bits */
<         buff2 = ((buff2 << 32) | (buff1 >> ready_bits));
<         strcpy (action, "Flush");
<         }
<       else
<         { /* add another bps bits to the buffer */
<         bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;
<         buff2 = (buff2 | (buff1 >> ready_bits));
<         strcpy (action, "Update");
<         }
<       ready_bits += bps;
---
> 	  /* shift in new bits */
> 	  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));
> 	  strcpy (action, "Flush");
> 	  }
> 	else
> 	  { /* add another bps bits to the buffer */
> 	  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;
> 	  buff2 = (buff2 | (buff1 >> ready_bits));
> 	  strcpy (action, "Update");
> 	  }
> 	ready_bits += bps;
3837,3847c4782,4793
<       if ((dumpfile != NULL) && (level == 3))
<         { 
<         dump_info (dumpfile, format, "",
< 	    "Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
< 		   row + 1, col + 1, s, src_byte, src_bit, dst - out);
<         dump_wide (dumpfile, format, "Match bits ", matchbits);
<         dump_data (dumpfile, format, "Src   bits ", src, 8);
<         dump_wide (dumpfile, format, "Buff1 bits ", buff1);
<         dump_wide (dumpfile, format, "Buff2 bits ", buff2);
<         dump_info (dumpfile, format, "", "Ready bits:   %d, %s", ready_bits, action); 
<         }
---
> 	if ((dumpfile != NULL) && (level == 3))
> 	  { 
> 	  dump_info (dumpfile, format, "",
> 		     "Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
> 		     row + 1, col + 1, s, src_byte, src_bit, dst - out);
> 	  dump_wide (dumpfile, format, "Match bits ", matchbits);
> 	  dump_data (dumpfile, format, "Src   bits ", src, 8);
> 	  dump_wide (dumpfile, format, "Buff1 bits ", buff1);
> 	  dump_wide (dumpfile, format, "Buff2 bits ", buff2);
> 	  dump_info (dumpfile, format, "", "Ready bits:   %d, %s", ready_bits, action); 
> 	  }
> 	}
3849,3910c4795
<     }
<   while (ready_bits > 0)
<     {
<     bytebuff1 = (buff2 >> 56);
<     *dst++ = bytebuff1;
<     buff2 = (buff2 << 8);
<     ready_bits -= 8;
<     }
< 
<   if ((dumpfile != NULL) && (level == 3))
<     {
<     dump_info (dumpfile, format, "",
<       "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
<       row + 1, col + 1, src_byte, src_bit, dst - out);
< 
<     dump_long (dumpfile, format, "Match bits ", matchbits);
<     dump_data (dumpfile, format, "Src   bits ", src, 4);
<     dump_long (dumpfile, format, "Buff1 bits ", buff1);
<     dump_long (dumpfile, format, "Buff2 bits ", buff2);
<     dump_byte (dumpfile, format, "Write bits1", bytebuff1);
<     dump_byte (dumpfile, format, "Write bits2", bytebuff2);
<     dump_info (dumpfile, format, "", "Ready bits:  %2d", ready_bits); 
<     }
< 
<   if ((dumpfile != NULL) && (level == 2))
<     {
<     dump_info (dumpfile, format, "combineSeparateSamples32bits","Output data");
<     dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);
<     }
<   
<   return (0);
<   } /* end combineSeparateSamples32bits */
< 
< static int 
< combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,
<                              uint32 row, uint32 width, uint16 spp, uint16 bps, 
<                              FILE *dumpfile, int format, int level)
<   {
<   int i, bytes_per_sample, bytes_per_pixel, dst_rowsize, shift_width;
<   uint32 col, col_offset;
<   unsigned char *src;
<   unsigned char *dst;
<   tsample_t s;
< 
<   src = srcbuffs[0];
<   dst = out;
<   if ((src == NULL) || (dst == NULL))
<     {
<     TIFFError("combineSeparateSamplesBytes","Invalid buffer address");
<     return (1);
<     }
< 
<   bytes_per_sample = (bps + 7) / 8; 
<   bytes_per_pixel  = ((bps * spp) + 7) / 8;
<   if (bytes_per_pixel < (bytes_per_sample + 1))
<     shift_width = bytes_per_sample;
<   else
<     shift_width = bytes_per_pixel;
< 
<   if ((dumpfile != NULL) && (level == 2))
<     {
<     for (s = 0; s < spp; s++)
---
>     while (ready_bits > 0)
3912,3913c4797,4800
<       dump_info (dumpfile, format, "combineSeparateSamplesBytes","Input data, Sample %d", s);
<       dump_buffer(dumpfile, format, 1, width, row, srcbuffs[s]);
---
>       bytebuff1 = (buff2 >> 56);
>       *dst++ = bytebuff1;
>       buff2 = (buff2 << 8);
>       ready_bits -= 8;
3915d4801
<     }
3917,3921c4803
<   dst_rowsize = ((bps * spp * width) + 7) / 8;
<   for (col = 0; col < width; col++)
<     {
<     col_offset = col * (bps / 8); 
<     for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)
---
>     if ((dumpfile != NULL) && (level == 3))
3923,3929c4805,4807
<       src = srcbuffs[s] + col_offset; 
<       for (i = 0; i < bytes_per_sample; i++)
<         *(dst + i) = *(src + i);
<       src += bytes_per_sample;
<       dst += bytes_per_sample;
<       }   
<     }
---
>       dump_info (dumpfile, format, "",
> 	         "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
> 		 row + 1, col + 1, src_byte, src_bit, dst - out);
3931,3935c4809,4816
<   if ((dumpfile != NULL) && (level == 2))
<     {
<     dump_info (dumpfile, format, "combineSeparateSamplesBytes","Output data, combined samples");
<     dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);
<     }
---
>       dump_long (dumpfile, format, "Match bits ", matchbits);
>       dump_data (dumpfile, format, "Src   bits ", src, 4);
>       dump_long (dumpfile, format, "Buff1 bits ", buff1);
>       dump_long (dumpfile, format, "Buff2 bits ", buff2);
>       dump_byte (dumpfile, format, "Write bits1", bytebuff1);
>       dump_byte (dumpfile, format, "Write bits2", bytebuff2);
>       dump_info (dumpfile, format, "", "Ready bits:  %2d", ready_bits); 
>       }
3936a4818,4824
>     if ((dumpfile != NULL) && (level == 2))
>       {
>       dump_info (dumpfile, format, "combineSeparateTileSamples32bits","Output data");
>       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);
>       }
>     }
>   
3938c4826,4827
<   } /* end combineSeparateSamplesBytes */
---
>   } /* end combineSeparateTileSamples32bits */
> 
3944,3946c4833,4837
<   int i, bytes_per_sample, bytes_per_pixel, shift_width;
<   uint16 bps;
<   uint32 row, src_rowsize, dst_rowsize;
---
>   int i, j, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;
>   int32  bytes_read = 0;
>   uint16 bps, nstrips, planar, strips_per_sample;
>   uint32 src_rowsize, dst_rowsize, rows_processed, rps;
>   uint32 rows_this_strip = 0;
3947a4839
>   tstrip_t  strip;
3948a4841
>   tsize_t stripsize    = TIFFStripSize(in);
3953,3954d4845
<   (void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);
< 
3960a4852,4858
>   memset (srcbuffs, '\0', sizeof(srcbuffs));
>   TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);
>   TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);
>   TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
>   if (rps > length)
>     rps = length;
> 
3982c4880,4887
<   /* allocate scanline buffers for each sample */
---
>   /* Libtiff seems to assume/require that data for separate planes are 
>    * written one complete plane after another and not interleaved in any way.
>    * Multiple scanlines and possibly strips of the same plane must be 
>    * written before data for any other plane.
>    */
>   nstrips = TIFFNumberOfStrips(in);
>   strips_per_sample = nstrips /spp;
> 
3986c4891
<     buff = _TIFFmalloc(src_rowsize);
---
>     buff = _TIFFmalloc(stripsize);
3990c4895
<                  "Unable to allocate read buffer for sample %d", s);
---
>                  "Unable to allocate strip read buffer for sample %d", s);
3998,3999c4903,4904
<   /* read and process one scanline from each sample */
<   for (row = 0; row < length; row++)
---
>   rows_processed = 0;
>   for (j = 0; (j < strips_per_sample) && (result == 1); j++)
4004,4006c4909,4912
<       /* read one scanline in the current sample color */
<       if (TIFFReadScanline(in, buff, row, s) < 0
< 	    && !ignore)
---
>       strip = (s * strips_per_sample) + j; 
>       bytes_read = TIFFReadEncodedStrip (in, strip, buff, stripsize);
>       rows_this_strip = bytes_read / src_rowsize;
>       if (bytes_read < 0 && !ignore)
4009,4014c4915,4923
< 	         "Error, can't read scanline %lu for sample %d",
< 		  (unsigned long) row, s + 1);
<         for (i = 0; i < s; i++)
<           _TIFFfree (srcbuffs[i]);
<         return (0);
<         }
---
> 	          "Error, can't read strip %lu for sample %d",
>          	   (unsigned long) strip, s + 1);
>         result = 0;
>         break;
>         }
> #ifdef DEVELMODE
>       TIFFError("", "Strip %2d, read %5d bytes for %4d scanlines, shift width %d", 
> 		strip, bytes_read, rows_this_strip, shift_width);
> #endif
4017,4018c4926,4928
<     /* combine the samples in each scanline */
<     dst = obuf + (row * dst_rowsize);
---
>     if (rps > rows_this_strip)
>       rps = rows_this_strip;
>     dst = obuf + (dst_rowsize * rows_processed);
4021,4023c4931,4933
<       if (combineSeparateSamplesBytes (srcbuffs, dst, row, width,
<                                       spp, bps, dump->infile,
<                                       dump->format, dump->level))
---
>       if (combineSeparateSamplesBytes (srcbuffs, dst, width, rps,
>                                        spp, bps, dump->infile, 
>                                        dump->format, dump->level))
4025,4027c4935,4936
<         for (i = 0; i < spp; i++)
<          _TIFFfree (srcbuffs[i]);
< 	return (0);
---
>         result = 0;
>         break;
4034,4043c4943
<         case 1: if (combineSeparateSamples8bits (srcbuffs, dst, row, width,
<                                                 spp, bps, dump->infile,
<                                                 dump->format, dump->level))
< 	          {
<                   for (i = 0; i < spp; i++)
<                     _TIFFfree (srcbuffs[i]);
< 	          return (0);
< 		  }
< 		break;
<         case 2: if (combineSeparateSamples16bits (srcbuffs, dst, row, width,
---
>         case 1: if (combineSeparateSamples8bits (srcbuffs, dst, width, rps,
4047,4050c4947,4949
<                   for (i = 0; i < spp; i++)
<                     _TIFFfree (srcbuffs[i]);
< 	          return (0);
< 		  }
---
>                   result = 0;
>                   break;
>       	          }
4052,4054c4951,4953
<         case 3: if (combineSeparateSamples24bits (srcbuffs, dst, row, width,
<                                                  spp, bps, dump->infile,
<                                                  dump->format, dump->level))
---
>         case 2: if (combineSeparateSamples16bits (srcbuffs, dst, width, rps,
>                                                   spp, bps, dump->infile,
>                                                   dump->format, dump->level))
4056,4058c4955,4956
<                   for (i = 0; i < spp; i++)
<                     _TIFFfree (srcbuffs[i]);
< 	          return (0);
---
>                   result = 0;
>                   break;
4060c4958,4965
< 
---
> 	        break;
>         case 3: if (combineSeparateSamples24bits (srcbuffs, dst, width, rps,
>                                                   spp, bps, dump->infile,
>                                                   dump->format, dump->level))
> 	          {
>                   result = 0;
>                   break;
>        	          }
4066,4068c4971,4973
<         case 8: if (combineSeparateSamples32bits (srcbuffs, dst, row, width,
<                                                  spp, bps, dump->infile,
<                                                  dump->format, dump->level))
---
>         case 8: if (combineSeparateSamples32bits (srcbuffs, dst, width, rps,
>                                                   spp, bps, dump->infile,
>                                                   dump->format, dump->level))
4070,4072c4975,4976
<                   for (i = 0; i < spp; i++)
<                     _TIFFfree (srcbuffs[i]);
< 	          return (0);
---
>                   result = 0;
>                   break;
4074c4978
< 		break;
---
> 	        break;
4076,4079c4980,4988
<                   for (i = 0; i < spp; i++)
<                     _TIFFfree (srcbuffs[i]);
< 	          return (0);
< 	}
---
>                   result = 0;
>                   break;
>         }
>       }
>  
>     if ((rows_processed + rps) > length)
>       {
>       rows_processed = length;
>       rps = length - rows_processed;
4080a4990,4991
>     else
>       rows_processed += rps;
4093c5004
<   return (1);
---
>   return (result);
4251c5162,5163
<     if (((image->xres == 0) || (image->yres == 0)) &&
---
>     if (((image->xres == 0) || (image->yres == 0)) && 
>          (crop->res_unit != RESUNIT_NONE) &&
4329,4332d5240
<       /*
<       buffsize = (uint32)
<           (((zwidth * image->bps + 7 ) / 8)  * image->spp * (zlength + 1));
<       */
4948c5856
< loadImage(TIFF* in, struct image_data *image, struct dump_opts * dump, unsigned char **read_ptr)
---
> loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr)
4951,4954c5859,5866
<   float    xres=0.0, yres=0.0;
<   uint16   nstrips, ntiles, planar, bps, spp, res_unit, photometric, orientation;
<   uint32   width, length, rowsperstrip;
<   uint32   stsize, tlsize, buffsize, scanlinesize;
---
>   float    xres = 0.0, yres = 0.0;
>   uint16   nstrips = 0, ntiles = 0, planar = 0;
>   uint16   bps = 0, spp = 0, res_unit = 0;
>   uint16   photometric = 0, orientation = 0, input_compression = 0;
>   uint32   width = 0, length = 0;
>   uint32   stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0;
>   uint32   tw = 0, tl = 0;       /* Tile width and length */
>   uint32   tile_rowsize = 0;
4964,4969c5876,5887
<   TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric);
<   TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width);
<   TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length);
<   TIFFGetField(in, TIFFTAG_XRESOLUTION, &xres);
<   TIFFGetField(in, TIFFTAG_YRESOLUTION, &yres);
<   TIFFGetField(in, TIFFTAG_RESOLUTIONUNIT, &res_unit);
---
>   if (! TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &photometric))
>     TIFFError("loadImage","Image lacks Photometric interpreation tag");
>   if (! TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width))
>     TIFFError("loadimage","Image lacks image width tag");
>   if(! TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))
>     TIFFError("loadimage","Image lacks image length tag");
>   TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres);
>   TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres);
>   if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit))
>     res_unit = RESUNIT_INCH;
>   if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression))
>     input_compression = COMPRESSION_NONE;
5025a5944,5947
>     TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);
>     TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);
> 
>     tile_rowsize  = TIFFTileRowSize(in);      
5026a5949,5959
>     
>     if (buffsize < (uint32)(ntiles * tl * tile_rowsize))
>       {
>       buffsize = ntiles * tl * tile_rowsize;
> #ifdef DEBUG2
>       TIFFError("loadImage",
> 	        "Tilesize %u is too small, using ntiles * tilelength * tilerowsize %lu",
>                 tlsize, (unsigned long)buffsize);
> #endif
>       }
>     
5029,5030c5962,5963
<                  "Tilesize: %u, Number of Tiles: %u, Scanline size: %u",
<                  tlsize, ntiles, scanlinesize);
---
>                  "Tilesize: %u, Number of Tiles: %u, Tile row size: %u",
>                  tlsize, ntiles, tile_rowsize);
5038a5972,5981
>     if (buffsize < (uint32) (((length * width * spp * bps) + 7) / 8))
>       {
>       buffsize =  ((length * width * spp * bps) + 7) / 8;
> #ifdef DEBUG2
>       TIFFError("loadImage",
> 	        "Stripsize %u is too small, using imagelength * width * spp * bps / 8 = %lu",
>                 stsize, (unsigned long)buffsize);
> #endif
>       }
> 
5043a5987,5992
>   
>   if (input_compression == COMPRESSION_JPEG)
>     {
>     jpegcolormode = JPEGCOLORMODE_RGB;
>     TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
>     }
5068c6017
<   _TIFFmemset(read_buff, '\0', buffsize);
---
> 
5080c6029
< 	   if (!(readContigStripsIntoBuffer(in, read_buff, length, width, spp)))
---
> 	     if (!(readContigStripsIntoBuffer(in, read_buff, length, width, spp, dump)))
5099c6048
< 	   if (!(readContigTilesIntoBuffer(in, read_buff, length, width, spp)))
---
> 	   if (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))
5107c6056
< 	   if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, spp)))
---
> 	   if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))
5278,5288c6227,6229
<                case 1:  if (extractContigSamplesShifted8bits (src, dst, img_width,
<                                                               sample, spp, bps, count, 
<                                                               first_col, last_col + 1,
<                                                               prev_trailing_bits))
<                           {
< 		          TIFFError("extractCompositeRegions",
<                                     "Unable to extract row %d", row);
< 		          return (1);
< 		          }
< 		        break;
<                case 2:  if (extractContigSamplesShifted16bits (src, dst, img_width,
---
>                case 1: if (bps == 1)
>                          { 
>                          if (extractContigSamplesShifted8bits (src, dst, img_width,
5292,5296c6233,6249
<                           {
< 		          TIFFError("extractCompositeRegions",
<                                     "Unable to extract row %d", row);
< 		          return (1);
< 		          }
---
>                            {
> 		           TIFFError("extractCompositeRegions",
>                                      "Unable to extract row %d", row);
> 		           return (1);
> 		           }
> 		         break;
> 			 }
>                        else
>                          if (extractContigSamplesShifted16bits (src, dst, img_width,
>                                                                 sample, spp, bps, count, 
>                                                                 first_col, last_col + 1,
>                                                                 prev_trailing_bits))
>                            {
> 		           TIFFError("extractCompositeRegions",
>                                      "Unable to extract row %d", row);
> 		           return (1);
> 		           }
5298c6251
<                case 3:  if (extractContigSamplesShifted24bits (src, dst, img_width,
---
>                case 2:  if (extractContigSamplesShifted24bits (src, dst, img_width,
5307a6261
>                case 3:
5355,5365c6309,6311
<                case 1:  if (extractContigSamplesShifted8bits (src, dst, img_width,
<                                                               sample, spp, bps, count, 
<                                                               first_col, last_col + 1,
<                                                               prev_trailing_bits))
<                           {
< 		          TIFFError("extractCompositeRegions",
<                                     "Unable to extract row %d", row);
< 		          return (1);
< 		          }
< 		        break;
<                case 2:  if (extractContigSamplesShifted16bits (src, dst, img_width,
---
>                case 1: if (bps == 1)
>                          { 
>                          if (extractContigSamplesShifted8bits (src, dst, img_width,
5369,5373c6315,6331
<                           {
< 		          TIFFError("extractCompositeRegions",
<                                     "Unable to extract row %d", row);
< 		          return (1);
< 		          }
---
>                            {
> 		           TIFFError("extractCompositeRegions",
>                                      "Unable to extract row %d", row);
> 		           return (1);
> 		           }
> 		         break;
> 			 }
>                        else
>                          if (extractContigSamplesShifted16bits (src, dst, img_width,
>                                                                 sample, spp, bps, count, 
>                                                                 first_col, last_col + 1,
>                                                                 prev_trailing_bits))
>                            {
> 		           TIFFError("extractCompositeRegions",
>                                      "Unable to extract row %d", row);
> 		           return (1);
> 		           }
5375c6333
<                case 3:  if (extractContigSamplesShifted24bits (src, dst, img_width,
---
>               case 2:  if (extractContigSamplesShifted24bits (src, dst, img_width,
5384a6343
>                case 3:
5493,5510c6452,6463
<       case 1: if (extractContigSamplesShifted8bits (src, dst, img_width,
<                                                     sample, spp, bps, count, 
<                                                     first_col, last_col + 1,
<                                                     prev_trailing_bits))
<                 {
< 	        TIFFError("extractSeparateRegion",
<                          "Unable to extract row %d", row);
< 		return (1);
< 		}
< 	      break;
<      case 2:  if (extractContigSamplesShifted16bits (src, dst, img_width,
<                                                      sample, spp, bps, count, 
<                                                      first_col, last_col + 1,
<                                                      prev_trailing_bits))
<                 {
< 		TIFFError("extractSeparateRegion",
<                           "Unable to extract row %d", row);
< 		return (1);
---
>       case 1: if (bps == 1)
>                 { 
>                 if (extractContigSamplesShifted8bits (src, dst, img_width,
>                                                       sample, spp, bps, count, 
>                                                       first_col, last_col + 1,
>                                                       prev_trailing_bits))
>                   {
> 		  TIFFError("extractSeparateRegion",
>                             "Unable to extract row %d", row);
> 		  return (1);
> 		  }
> 		  break;
5511a6465,6474
>               else
>                 if (extractContigSamplesShifted16bits (src, dst, img_width,
>                                                        sample, spp, bps, count, 
>                                                        first_col, last_col + 1,
>                                                        prev_trailing_bits))
>                   {
> 		  TIFFError("extractSeparateRegion",
>                             "Unable to extract row %d", row);
> 		  return (1);
> 		  }
5513c6476
<      case 3:  if (extractContigSamplesShifted24bits (src, dst, img_width,
---
>       case 2:  if (extractContigSamplesShifted24bits (src, dst, img_width,
5523,5524c6486,6488
<      case 4:
<      case 5:  if (extractContigSamplesShifted32bits (src, dst, img_width,
---
>       case 3:
>       case 4:
>       case 5:  if (extractContigSamplesShifted32bits (src, dst, img_width,
5557c6521
< #ifdef DEBUG2
---
> #ifdef DEVELMODE
5573c6537
< #ifdef DEBUG2
---
> #ifdef DEVELMODE
5596c6560
< #ifdef DEBUG2
---
> #ifdef DEVELMODE
5614c6578
< #ifdef DEBUG2
---
> #ifdef DEVELMODE
5632c6596
< #ifdef DEBUG2
---
> #ifdef DEVELMODE
5655c6619
< #ifdef DEBUG2
---
> #ifdef DEVELMODE
5673c6637
< #ifdef DEBUG2
---
> #ifdef DEVELMODE
5689c6653
< #ifdef DEBUG2
---
> #ifdef DEVELMODE
5698c6662
< #ifdef DEBUG2
---
> #ifdef DEVELMODE
5713c6677
< #ifdef DEBUG2
---
> #ifdef DEVELMODE
5721c6685
< #ifdef DEBUG2
---
> #ifdef DEVELMODE
5731c6695
< #ifdef DEBUG2
---
> #ifdef DEVELMODE
5735c6699
< #ifdef DEBUG2
---
> #ifdef DEVELMODE
5741c6705
< #ifdef DEBUG2
---
> #ifdef DEVELMODE
5880,5884d6843
< #ifdef DEBUG
<   TIFFError("",
<     "Writing %d sections for each original page. Hres: %3.2f Vres: %3.2f\n", 
<           page->rows * page->cols, hres, vres);
< #endif
5907,5911d6865
< #ifdef DEBUG
<     TIFFError ("", "\nSection: %d, Width: %4d, Length: %4d, x1: %4d  x2: %4d  y1: %4d  y2: %4d\n",
<              i + 1, width, length, sections[i].x1, sections[i].x2, sections[i].y1, sections[i].y2);
< #endif
< 
5930a6885,6887
>  * It will have to be updated significantly if support is added to
>  * extract one or more samples from original image since the 
>  * original code assumes we are always copying all samples.
5938a6896,6897
>   uint16 input_compression, input_photometric;
>   uint16 input_jpeg_colormode, input_planar;
5941,5945d6899
< #ifdef DEBUG
<   TIFFError ("",
< "\nWriting single section: Width %d Length: %d Hres: %4.1f, Vres: %4.1f\n\n",
< 	   width, length, hres, vres);
< #endif
5950a6905,6906
> 
>   TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression);
5954,5957c6910,6918
<     CopyField(TIFFTAG_COMPRESSION, compression);
< 
<   if (compression == COMPRESSION_JPEG) {
<     uint16 input_compression, input_photometric;
---
>     {
>     if (input_compression == COMPRESSION_OJPEG)
>       {
>       TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);
>       compression = COMPRESSION_JPEG;
>       }
>     else
>       CopyField(TIFFTAG_COMPRESSION, compression);
>     }
5959,5970c6920,6937
<     if (TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression)
<         && input_compression == COMPRESSION_JPEG) {
<           TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
<         }
<     if (TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &input_photometric)) {
< 	if(input_photometric == PHOTOMETRIC_RGB) {
< 	   if (jpegcolormode == JPEGCOLORMODE_RGB)
< 	     TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
< 	   else
< 	     TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
< 	   } else
< 	      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);
---
>   TIFFGetField(in, TIFFTAG_JPEGCOLORMODE, &input_jpeg_colormode);
> #ifdef DEBUG2
>   TIFFError("writeSingleSection", "Input compression: %s",
> 	    (input_compression == COMPRESSION_OJPEG) ? "Old Jpeg" :
> 	    ((input_compression == COMPRESSION_JPEG) ?  "New Jpeg" : "Non Jpeg"));
> #endif
>   if (compression == COMPRESSION_JPEG)
>     {
>     if (TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &input_photometric))
>       {
>       if ((input_photometric == PHOTOMETRIC_PALETTE) ||  /* color map indexed */
>           (input_photometric == PHOTOMETRIC_MASK))       /* $holdout mask */
>         {
> 	TIFFError ("writeSingleSection",
>                    "JPEG compression cannot be used with %s image data",
> 		   (input_photometric == PHOTOMETRIC_PALETTE) ?
>                    "palette" : "mask");
>         return (-1);
5971a6939,6947
>       if (input_photometric == PHOTOMETRIC_RGB)
>         {
> 	if (jpegcolormode == JPEGCOLORMODE_RGB)
> 	  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
> 	else
> 	  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
> 	} 
>       else
> 	TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);
5973c6949,6950
<   else 
---
>     }
>   else
5976c6953
<        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?
---
>       TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?
5980a6958,6968
> 
>   if (((TIFFTAG_PHOTOMETRIC == PHOTOMETRIC_LOGL) ||
>        (TIFFTAG_PHOTOMETRIC ==  PHOTOMETRIC_LOGLUV)) &&
>       ((compression != COMPRESSION_SGILOG) && 
>        (compression != COMPRESSION_SGILOG24)))
>     {
>     TIFFError("writeSingleSection",
>               "LogL and LogLuv data require SGI_LOG or SGI_LOG24");
>     return (-1);
>     }
> 
5991c6979
<    * as per EXIF standard. Original tiffcp code removed here.
---
>    * as per EXIF standard.
6009c6997
<     if (tilewidth == (uint32) -1)
---
>     if (tilewidth == (uint32) 0)
6011c6999
<     if (tilelength == (uint32) -1)
---
>     if (tilelength == (uint32) 0)
6014,6018c7002,7003
<     if (tilewidth > width)
<       tilewidth = width;
<     if (tilelength > length)
<       tilelength = length;
< 
---
>     if (tilewidth == 0 || tilelength == 0)
>       TIFFDefaultTileSize(out, &tilewidth, &tilelength);
6028,6033c7013,7021
< 	if (rowsperstrip == (uint32) 0) {
< 	  if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip)) {
< 	      rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);
< 	     }
< 	  if (rowsperstrip > length && rowsperstrip != (uint32)-1)
< 	       rowsperstrip = length;
---
> 	if (rowsperstrip == (uint32) 0)
>           {
> 	  if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip))
> 	    rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);
>           if (compression != COMPRESSION_JPEG)
>             {
>   	    if (rowsperstrip > length)
> 	      rowsperstrip = length;
> 	    }
6035,6037c7023,7026
< 	else if (rowsperstrip == (uint32) -1)
< 		rowsperstrip = length;
< 		TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);
---
> 	else 
>           if (rowsperstrip == (uint32) -1)
> 	    rowsperstrip = length;
> 	TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);
6038a7028,7029
> 
>   TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &input_planar);
6048a7040,7042
>     /* These are references to GLOBAL variables set by defaults
>      * and /or the compression flag
>      */
6050,6051c7044,7054
<          TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);
< 	 TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);
---
>          if (((bps % 8) == 0) || ((bps % 12) == 0))
> 	   {
>            TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);
> 	   TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
>            }
>          else
>            {
> 	   TIFFError("writeCroppedImage",
>                      "JPEG compression requires 8 or 12 bits per sample");
>            return (-1);
>            }
6123,6125c7126
<       {
<       writeBufferToContigTiles (out, sect_buff, length, width, spp);
<       }
---
>       writeBufferToContigTiles (out, sect_buff, length, width, spp, dump);
6132,6134c7133
<       {
<       writeBufferToContigStrips (out, sect_buff, length, width, spp);
<       }
---
>       writeBufferToContigStrips (out, sect_buff, length);
6136d7134
<       {
6138d7135
<       }
6548c7545,7555
< /* The code in this function is heavily indebted to code from tiffcp. */
---
> /* Code in this function is heavily indebted to code in tiffcp
>  * with modifications by Richard Nolde to handle orientation correctly.
>  * It will have to be updated significantly if support is added to
>  * extract one or more samples from original image since the 
>  * original code assumes we are always copying all samples.
>  * Use of global variables for config, compression and others
>  * should be replaced by addition to the crop_mask struct (which
>  * will be renamed to proc_opts indicating that is controlls
>  * user supplied processing options, not just cropping) and 
>  * then passed in as an argument.
>  */
6554a7562,7563
>   uint16 input_compression, input_photometric;
>   uint16 input_jpeg_colormode, input_planar;
6561a7571,7572
> 
>   TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression);
6565,6568c7576,7584
<     CopyField(TIFFTAG_COMPRESSION, compression);
< 
<   if (compression == COMPRESSION_JPEG) {
<     uint16 input_compression, input_photometric;
---
>     {
>     if (input_compression == COMPRESSION_OJPEG)
>       {
>       TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);
>       compression = COMPRESSION_JPEG;
>       }
>     else
>       CopyField(TIFFTAG_COMPRESSION, compression);
>     }
6570,6581c7586,7603
<     if (TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression)
<         && input_compression == COMPRESSION_JPEG) {
<           TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
<         }
<     if (TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &input_photometric)) {
< 	if(input_photometric == PHOTOMETRIC_RGB) {
< 	   if (jpegcolormode == JPEGCOLORMODE_RGB)
< 	     TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
< 	   else
< 	     TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
< 	   } else
< 	      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);
---
>   TIFFGetField(in, TIFFTAG_JPEGCOLORMODE, &input_jpeg_colormode);
> #ifdef DEBUG2
>   TIFFError("writeCroppedImage", "Input compression: %s",
> 	    (input_compression == COMPRESSION_OJPEG) ? "Old Jpeg" :
> 	    ((input_compression == COMPRESSION_JPEG) ?  "New Jpeg" : "Non Jpeg"));
> #endif
>   if (compression == COMPRESSION_JPEG)
>     {
>     if (TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &input_photometric))
>       {
>       if ((input_photometric == PHOTOMETRIC_PALETTE) ||  /* color map indexed */
>           (input_photometric == PHOTOMETRIC_MASK))       /* $holdout mask */
>         {
> 	TIFFError ("writeCroppedImage",
>                    "JPEG compression cannot be used with %s image data",
> 		   (input_photometric == PHOTOMETRIC_PALETTE) ?
>                    "palette" : "mask");
>         return (-1);
6583c7605,7615
<   }
---
>       if (input_photometric == PHOTOMETRIC_RGB)
>         {
> 	if (jpegcolormode == JPEGCOLORMODE_RGB)
> 	  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
> 	else
> 	  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
> 	} 
>       else
> 	TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);
>       }
>     }
6591a7624,7634
> 
>   if (((TIFFTAG_PHOTOMETRIC == PHOTOMETRIC_LOGL) ||
>        (TIFFTAG_PHOTOMETRIC ==  PHOTOMETRIC_LOGLUV)) &&
>       ((compression != COMPRESSION_SGILOG) && 
>        (compression != COMPRESSION_SGILOG24)))
>     {
>     TIFFError("writeCroppedImage",
>               "LogL and LogLuv data require SGI_LOG or SGI_LOG24");
>     return (-1);
>     }
> 
6620c7663
<     if (tilewidth == (uint32) -1)
---
>     if (tilewidth == (uint32) 0)
6622c7665
<     if (tilelength == (uint32) -1)
---
>     if (tilelength == (uint32) 0)
6625,6630c7668,7669
<     if (tilewidth > width)
<       tilewidth = width;
<     if (tilelength > length)
<       tilelength = length;
< 
<     TIFFDefaultTileSize(out, &tilewidth, &tilelength);
---
>     if (tilewidth == 0 || tilelength == 0)
>       TIFFDefaultTileSize(out, &tilewidth, &tilelength);
6642d7680
<             {
6643a7682,7685
>           if (compression != COMPRESSION_JPEG)
>             {
>   	    if (rowsperstrip > length)
> 	      rowsperstrip = length;
6645,6646d7686
< 	  if (rowsperstrip > length)
< 	    rowsperstrip = length;
6652a7693,7694
> 
>   TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &input_planar);
6664,6665c7706,7716
<          TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);
< 	 TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);
---
>          if (((bps % 8) == 0) || ((bps % 12) == 0))
> 	   {
>            TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);
> 	   TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
>            }
>          else
>            {
> 	   TIFFError("writeCroppedImage",
>                      "JPEG compression requires 8 or 12 bits per sample");
>            return (-1);
>            }
6676a7728,7733
>         if (bps != 1)
>           {
> 	  TIFFError("writeCroppedImage",
>             "Group 3/4 compression is not usable with bps > 1");
>           return (-1);
> 	  }
6690c7747,7750
< 	break;
---
> 	 break;
>     case COMPRESSION_NONE:
>          break;
>     default: break;
6730,6732c7790
<       {
<       writeBufferToContigTiles (out, crop_buff, length, width, spp);
<       }
---
>       writeBufferToContigTiles (out, crop_buff, length, width, spp, dump);
6739,6741c7797
<       {
<       writeBufferToContigStrips (out, crop_buff, length, width, spp);
<       }
---
>       writeBufferToContigStrips (out, crop_buff, length);
6743d7798
<       {
6745d7799
<       }
7244,7247c8298,8305
<                     case 1: if (reverseSamples8bits(spp, bps, width, src, dst))
<                               {
< 		              _TIFFfree(rbuff);
<                               return (-1);
---
>                     case 1: if (bps == 1)
> 			      {
>                               if (reverseSamples8bits(spp, bps, width, src, dst))
>                                 {
> 		                _TIFFfree(rbuff);
>                                 return (-1);
>                                 }
>                               break;
7249,7250c8307
<                              break;
<                     case 2: if (reverseSamples16bits(spp, bps, width, src, dst))
---
>                             if (reverseSamples16bits(spp, bps, width, src, dst))
7256c8313
<                     case 3: if (reverseSamples24bits(spp, bps, width, src, dst))
---
>                     case 2: if (reverseSamples24bits(spp, bps, width, src, dst))
7261a8319
>                     case 3: 
7305c8363,8373
<                     case 1: if (rotateContigSamples8bits(rotation, spp, bps, width, 
---
>                     case 1: if (bps == 1)
> 			      {
>                               if (rotateContigSamples8bits(rotation, spp, bps, width, 
> 				   	                 length, col, src, dst))
>                                 {
> 		                _TIFFfree(rbuff);
>                                 return (-1);
>                                 }
>                               break;
>                               }
>                             if (rotateContigSamples16bits(rotation, spp, bps, width, 
7312c8380
<                     case 2: if (rotateContigSamples16bits(rotation, spp, bps, width, 
---
>                     case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, 
7319,7325c8387
<                     case 3: if (rotateContigSamples24bits(rotation, spp, bps, width, 
< 				                          length, col, src, dst))
<                               {
< 		              _TIFFfree(rbuff);
<                               return (-1);
<                               }
<                              break;
---
>                     case 3: 
7378c8440,8450
<                     case 1: if (rotateContigSamples8bits(rotation, spp, bps, width, 
---
>                     case 1: if (bps == 1)
> 			      {
>                               if (rotateContigSamples8bits(rotation, spp, bps, width, 
> 				   	                 length, col, src, dst))
>                                 {
> 		                _TIFFfree(rbuff);
>                                 return (-1);
>                                 }
>                               break;
>                               }
>                             if (rotateContigSamples16bits(rotation, spp, bps, width, 
7385c8457
<                     case 2: if (rotateContigSamples16bits(rotation, spp, bps, width, 
---
>                     case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, 
7392,7398c8464
<                     case 3: if (rotateContigSamples24bits(rotation, spp, bps, width, 
< 				                          length, col, src, dst))
<                               {
< 		              _TIFFfree(rbuff);
<                               return (-1);
<                               }
<                              break;
---
>                     case 3: 
7439c8505
<   uint8    matchbits = 0, maskbits = 0;
---
>   uint8    match_bits = 0, mask_bits = 0;
7452c8518
<   maskbits =  (uint8)-1 >> ( 8 - bps);
---
>   mask_bits =  (uint8)-1 >> ( 8 - bps);
7472,7473c8538,8539
<       matchbits = maskbits << (8 - src_bit - bps); 
<       buff1 = ((*src) & matchbits) << (src_bit);
---
>       match_bits = mask_bits << (8 - src_bit - bps); 
>       buff1 = ((*src) & match_bits) << (src_bit);
7494a8561
> 
7501c8568
<   uint32   src_byte = 0, src_bit = 0;
---
>   uint32   src_byte = 0, high_bit = 0;
7503c8570
<   uint16   matchbits = 0, maskbits = 0;
---
>   uint16   match_bits = 0, mask_bits = 0;
7518c8585
<   maskbits =  (uint16)-1 >> (16 - bps);
---
>   mask_bits =  (uint16)-1 >> (16 - bps);
7529c8596
<         src_bit  = bit_offset % 8;
---
>         high_bit  = bit_offset % 8;
7534c8601
<         src_bit  = (bit_offset + (sample * bps)) % 8;
---
>         high_bit  = (bit_offset + (sample * bps)) % 8;
7538c8605
<       matchbits = maskbits << (16 - src_bit - bps); 
---
>       match_bits = mask_bits << (16 - high_bit - bps); 
7551c8618
<       buff1 = (buff1 & matchbits) << (src_bit);
---
>       buff1 = (buff1 & match_bits) << (high_bit);
7585c8652
<   uint32   src_byte = 0, src_bit = 0;
---
>   uint32   src_byte = 0, high_bit = 0;
7587c8654
<   uint32   matchbits = 0, maskbits = 0;
---
>   uint32   match_bits = 0, mask_bits = 0;
7602c8669
<   maskbits =  (uint32)-1 >> (32 - bps);
---
>   mask_bits =  (uint32)-1 >> (32 - bps);
7613c8680
<         src_bit  = bit_offset % 8;
---
>         high_bit  = bit_offset % 8;
7618c8685
<         src_bit  = (bit_offset + (sample * bps)) % 8;
---
>         high_bit  = (bit_offset + (sample * bps)) % 8;
7622c8689
<       matchbits = maskbits << (32 - src_bit - bps); 
---
>       match_bits = mask_bits << (32 - high_bit - bps); 
7639c8706
<       buff1 = (buff1 & matchbits) << (src_bit);
---
>       buff1 = (buff1 & match_bits) << (high_bit);
7683c8750
<   uint32 src_byte = 0, src_bit = 0;
---
>   uint32 src_byte = 0, high_bit = 0;
7686c8753
<   uint64 maskbits = 0, matchbits = 0;
---
>   uint64 mask_bits = 0, match_bits = 0;
7702c8769
<   maskbits =  (uint64)-1 >> (64 - bps);
---
>   mask_bits =  (uint64)-1 >> (64 - bps);
7721c8788
<         src_bit  = bit_offset % 8;
---
>         high_bit  = bit_offset % 8;
7726c8793
<         src_bit  = (bit_offset + (sample * bps)) % 8;
---
>         high_bit  = (bit_offset + (sample * bps)) % 8;
7730c8797
<       matchbits = maskbits << (64 - src_bit - bps); 
---
>       match_bits = mask_bits << (64 - high_bit - bps); 
7765c8832
<       buff1 = (buff3 & matchbits) << (src_bit);
---
>       buff1 = (buff3 & match_bits) << (high_bit);
7921,7928c8988
<                     case 1: if (reverseSamples8bits(spp, bps, width, src, line_buff))
<                               {
< 		              _TIFFfree(line_buff);
<                               return (-1);
<                               }
<                              _TIFFmemcpy (src, line_buff, rowsize);
<                              break;
<                     case 2: if (reverseSamples16bits(spp, bps, width, src, line_buff))
---
>                     case 1: if (reverseSamples16bits(spp, bps, width, src, line_buff))
7935c8995
<                     case 3: if (reverseSamples24bits(spp, bps, width, src, line_buff))
---
>                     case 2: if (reverseSamples24bits(spp, bps, width, src, line_buff))
7941a9002
>                     case 3: 
